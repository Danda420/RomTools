#!/bin/bash
DIRTOOLS=$PWD
DIRIN=$DIRTOOLS/rom_input
DIROUT=$DIRTOOLS/rom_output
DIRROM=$DIRTOOLS/ROM
DIRSCRIPTS=$DIRTOOLS/scripts
MERGE=$DIRTOOLS/scripts/merge_non_dynamic
OPLUSMERGE=$DIRTOOLS/scripts/oplus
DIRSUPER=$DIRTOOLS/ROM/super
erofsdir=$DIRROM/erofs
partitions="system vendor odm product system_ext"
oplus_partitions="my_bigball my_carrier my_company my_engineering my_heytap my_manifest my_preload my_product my_region my_stock"
G='\033[1;32m'
R='\033[1;31m'
NC='\033[0m'

restart_tool() {
	echo " "
	while true; do
	   echo "start tools again? (y/n)"
	   read -p "" yn
	   case $yn in
		[Yy]* ) start_tools;;
		[Nn]* ) 
		clear
		exit;;   
		* ) echo "please choose yes or no";;
	    esac
	done
}

banner() {
	clear
	echo -e "${G}========================="
	echo -e "${G}   ROM TOOLS FOR LINUX   "
	echo -e "${G}        by  Danda        "
	echo -e "${G}=========================${NC}"
}

give_perm() {
	for partition in $partitions
	do
	  sudo chown -R $USER:$USER $DIRROM/$partition >> /dev/null 2>&1
	done
}

restore_perm() {
	for partition in $partitions
	do
		if [[ $partition == vendor ]]; then
			sudo chown -R 0:0 $DIRROM/vendor/
			sudo chown 0:2000 $(sudo find $DIRROM/vendor -type d)
			sudo chown -R 0:2000 $DIRROM/vendor/bin
			sudo chown 0:2000 $DIRROM/vendor/addon/*
		elif [[ $partition == system ]]; then
			sudo chown -R 0:0 $DIRROM/system
			sudo chown -R 0:2000 $DIRROM/system/system/bin
		else
			sudo chown -R 0:0 $DIRROM/$partition
			sudo chown -R 0:2000 $DIRROM/$partition/bin
		fi
	done
}

setup() {
	clear
	if [[ -d $DIRTOOLS/ROM ]] && [[ -d $DIRTOOLS/rom_input ]] && [[ -d $DIRTOOLS/rom_output ]]; then

		echo ""

	else
		echo "creating dirs"

		mkdir $DIRTOOLS/rom_input
		mkdir $DIRTOOLS/rom_output
		mkdir $DIRTOOLS/ROM
		mkdir $DIRTOOLS/ROM/odm
		mkdir $DIRTOOLS/ROM/product
		mkdir $DIRTOOLS/ROM/system
		mkdir $DIRTOOLS/ROM/system_ext
		mkdir $DIRTOOLS/ROM/vendor
		mkdir $DIRTOOLS/ROM/super

		echo "Done!"
	fi
}

clean() {
	clear
	echo "cleaning..."

	rm -rf $DIRIN
	rm -rf $DIROUT
	sudo rm -rf $DIRROM/EXT4
	rm -rf $DIRROM
	sudo rm -rf $DIRSCRIPTS/log.txt
	sudo rm -rf $DIRSCRIPTS/bin/__pycache__
	sudo rm -rf $DIRSCRIPTS/bin/*.pyc

	echo "Done!"
}

resize_img_smallest(){
	sudo e2fsck -yf $DIRIMG_RESIZE_SMALLEST > /dev/null 2>&1
	sudo resize2fs -M $DIRIMG_RESIZE_SMALLEST > /dev/null 2>&1
	sudo e2fsck -yf $DIRIMG_RESIZE_SMALLEST > /dev/null 2>&1
}

convert_erofs_ext4(){
	if [[ -f $DIRIN/$partition.img ]]; then
		cd $DIRSCRIPTS
		echo " "
		echo "Starting conversion..."
		echo ""
		$DIRSCRIPTS/bin/erofs-ext4 $DIRIN/$partition.img $partition
		rm -rf $DIRIN/$partition.img
		mv $DIRSCRIPTS/$partition.img $DIROUT/
		echo ""
		echo "Conversion done..."
		echo "Output: $DIROUT"
		echo ""
		cd $DIRTOOLS
	else
		echo ""
		echo -e "${R}there's no image named "$partition.img" in $DIRIN"
		echo -e "${NC}"
	 fi
}
		
rebuild_ext4(){
	if [[ -f $DIRIN/$partition.img ]]; then
		echo " "
		echo "Starting rebuilding..."
		echo ""
		echo "- Extracting $partition"
		mkdir $DIRROM/rebuildimg
		sudo $DIRSCRIPTS/bin/imgextractor.py $DIRIN/$partition.img $DIRROM/rebuildimg > /dev/null 2>&1
		rm -rf $DIRIN/$partition.img
		foldersize=$(sudo du -s -B1 $DIRROM/rebuildimg/$partition | awk '{print $1}')
		SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
			SIZE=`sudo du -sk $DIRROM/rebuildimg/$partition | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		echo "- Rebuilding $partition..."
		if [[ $partition == system ]] || [[ $partition == system_a ]] || [[ $partition == system_b ]]; then
			sudo $DIRSCRIPTS/bin/make_ext4fs -J -T -1 -S "$DIRROM/rebuildimg/config/$partition/${partition}_file_contexts" -C "$DIRROM/rebuildimg/config/$partition/${partition}_fs_config" -l "$SIZE" -L "/" -a "/$partition" "$DIROUT/$partition.img" "$DIRROM/rebuildimg/$partition" > /dev/null 2>&1
		else
			sudo $DIRSCRIPTS/bin/make_ext4fs -J -T -1 -S "$DIRROM/rebuildimg/config/$partition/${partition}_file_contexts" -C "$DIRROM/rebuildimg/config/$partition/${partition}_fs_config" -l "$SIZE" -L "$partition" -a "/$partition" "$DIROUT/$partition.img" "$DIRROM/rebuildimg/$partition" > /dev/null 2>&1
		fi
		DIRIMG_RESIZE_SMALLEST=$DIROUT/$partition.img
		resize_img_smallest
		sudo rm -rf $DIRROM/rebuildimg
		echo "- Done!"
		echo ""
		echo "Rebuild done..."
		echo "Output: $DIROUT"
		echo ""
	 else
		echo ""
		echo -e "${R}there's no image named "$partition.img" in $DIRIN"
		echo -e "${NC}"
	fi
}

rebuild_ext4_single() {
		clear
		echo "make sure image is on rom_input folder"
		echo " "
		echo "Input image name :"
		read
		partition=$REPLY
		if [[ $(blkid -o value -s TYPE $DIRIN/$partition.img) == ext4 ]]; then
		   rebuild_ext4
		else
		   echo ""
		   echo -e "${R}$partition.img fs type is $(blkid -o value -s TYPE $DIRIN/$partition.img), aborting..."
		   echo -e "${NC}"
		fi
}

datbr_raw() {
	clear
	echo " "
	echo "Input image/partition name :"
	read
	imgname=$REPLY

	if [ -f $DIRIN/$imgname.new.dat.br ]; then

		echo "Unpacking..."
		echo " "
		brotli -d $DIRIN/$imgname.new.dat.br

		rm -rf $DIRIN/$imgname.new.dat.br

		python3 $DIRSCRIPTS/bin/sdat2img.py $DIRIN/$imgname.transfer.list $DIRIN/$imgname.new.dat $DIROUT/$imgname.img  >> /dev/null 2>&1
		echo " "
		echo "Cleaning input folder..."

		rm -rf $DIRIN/$imgname.*

		echo " "
		echo "Done! Output : $DIROUT"
	else

		echo -e "${R}there's no image "$imgname.new.dat.br"${NC}"
	fi
}

compress_zstd() {
	clear
	echo " "
	echo "Input file name :"
	read
	filename=$REPLY
	
	if [ -f $DIRIN/$filename ]; then
		echo " "
		echo "Input zstd suffix (leave it empty if you want .zst) :"
		read
		ZSTDSUFFIX=.$REPLY
		if [[ $ZSTDSUFFIX == "." ]]; then
			ZSTDSUFFIX=.zst
		elif [[ $ZSTDSUFFIX == ". " ]]; then
			ZSTDSUFFIX=""
		fi
		
		echo " "
		echo "Input zstd compression lvl (1-19) :"
		read
		ZSTDLVL=$REPLY
		
		echo " "
		echo "Compressing $filename to ${filename}$ZSTDSUFFIX (zstd)"
		zstd -${ZSTDLVL} $DIRIN/$filename -o $DIROUT/${filename}$ZSTDSUFFIX
		rm -rf $DIRIN/$filename
		echo " "
		echo "Done! Output : $DIROUT"
	else

		echo -e "${R}there's no file named "$filename" in $DIRIN ${NC}"
	fi	
}

decompress_zstd() {
	clear
	echo " "
	echo "Input file name :"
	read
	filename=$REPLY
	
	if [ -f $DIRIN/$filename ]; then
		mv $DIRIN/$filename $DIRIN/$filename.zst
		
		echo " "
		echo "Input $filename output name :"
		read
		outputname=$REPLY
		
		echo " "
		echo "Decompressing $filename (zstd)"
		zstd -d $DIRIN/$filename.zst -o $DIROUT/$outputname
		rm -rf $DIRIN/$filename.*
		echo " "
		echo "Done! Output : $DIROUT"
	else

		echo -e "${R}there's no file named "$filename" in $DIRIN ${NC}"
	fi	
}

unpack_ext4() {
	if [[ -f $DIRIN/$image.img ]]; then
	   if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == ext4 ]]; then
		if [[ ! -d $DIRROM/EXT4 ]]; then
			mkdir $DIRROM/EXT4
		fi
		echo ""
		sudo $DIRSCRIPTS/bin/imgextractor.py $DIRIN/$image.img $DIRROM/EXT4
		sudo chown -R $USER:$USER $DIRROM/EXT4
		echo ""
		echo "Output: $DIRROM/EXT4/$image"
		rm -rf $DIRIN/$image.img
	   else
	   	echo ""
		echo -e "${R}$image.img fs type is $(blkid -o value -s TYPE $DIRIN/$image.img), aborting..."
		echo -e "${NC}"
	   fi
	else
		echo -e "${R}Error: no image named $image.img in $DIRIN"
		echo -e "${NC}"
	fi
}

repack_ext4_cmd() {
	if [[ $image == system ]] || [[ $image == system_a ]] || [[ $image == system_b ]]; then
		sudo $DIRSCRIPTS/bin/make_ext4fs -J -T -1 -S "$DIRROM/EXT4/config/$image/${image}_file_contexts" -C "$DIRROM/EXT4/config/$image/${image}_fs_config" -l "$SIZE" -L "/" -a "/$image" "$DIROUT/$image.new.img" "$DIRROM/EXT4/$image"
	else
		sudo $DIRSCRIPTS/bin/make_ext4fs -J -T -1 -S "$DIRROM/EXT4/config/$image/${image}_file_contexts" -C "$DIRROM/EXT4/config/$image/${image}_fs_config" -l "$SIZE" -L "$image" -a "/$image" "$DIROUT/$image.new.img" "$DIRROM/EXT4/$image"
	fi
}

unpack_ext4_img() {
	clear
	echo "make sure image is on rom_input folder"
	echo " "
	echo "Input image name :"
	read
	image=$REPLY
	unpack_ext4
}

repack_ext4_img_foldersize() {
	clear
	echo " "
	echo "Input image name that you want to repack :"
	read
	image=$REPLY
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo ""
		echo "- Repacking $image..."
		foldersize=$(sudo du -s -B1 $DIRROM/EXT4/$image | awk '{print $1}')
		SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		repack_ext4_cmd
		DIRIMG_RESIZE_SMALLEST=$DIROUT/$image.new.img
		resize_img_smallest
		echo ""
		echo "- Done!"
		echo ""
		echo "Output: $DIROUT/$image.new.img"
	else
		echo -e "${R}Error: no unpacked image named $image in $DIRROM/EXT4"
		echo -e "${NC}"
	fi
}

repack_ext4_img_samesize() {
	clear
	echo " "
	echo "Input image name that you want to repack :"
	read
	image=$REPLY
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo ""
		echo "- Repacking $image..."
		SIZE=$(cat $DIRROM/EXT4/config/$image/${image}_size.txt)
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		repack_ext4_cmd
		echo ""
		echo "- Done!"
		echo ""
		echo "Output: $DIROUT/$image.new.img"
	else
		echo -e "${R}Error: no unpacked image named $image in $DIRROM/EXT4"
		echo -e "${NC}"
	fi
}

repack_ext4_img_inputsize() {
	clear
	echo " "
	echo "Input image name that you want to repack :"
	read
	image=$REPLY
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo " "
		echo "Input partition size in bytes :"
		read
		SIZE=$REPLY
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		echo ""
		echo "- Repacking $image..."
		repack_ext4_cmd
		echo ""
		echo "- Done!"
		echo ""
		echo "Output: $DIROUT/$image.new.img"
	else
		echo -e "${R}Error: no unpacked image named $image in $DIRROM/EXT4"
		echo -e "${NC}"
	fi
}

erofs_ext4_main() {
	erofs_ext4_normal() {
		clear
		echo "make sure image is on rom_input folder"
		echo " "
		echo "Input image name :"
		read
		partition=$REPLY
		if [[ $(blkid -o value -s TYPE $DIRIN/$partition.img) == erofs ]]; then
		   convert_erofs_ext4
		else
		   echo ""
		   echo -e "${R}$partition.img fs type is $(blkid -o value -s TYPE $DIRIN/$partition.img), aborting..."
		   echo -e "${NC}"
		fi
	}

	erofs_ext4_oplus() {
		clear
		for partition in $oplus_partitions
		do
		  convert_erofs_ext4
		done
		if [[ $(blkid -o value -s TYPE $DIRIN/product.img) == erofs ]]; then
		    partition=product
		    convert_erofs_ext4
		else
		    partition=product
		    rebuild_ext4
		fi
		    partition=system_ext
		    convert_erofs_ext4
		    partition=system
		    convert_erofs_ext4
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Convert erofs images to ext4"
	    echo "2. Convert OPlus my_xxx,system,system_ext partitions to ext4"
	    echo "3. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	erofs_ext4_normal
	restart_tool;;

		2 ) 
	   
	erofs_ext4_oplus
	restart_tool;;

		3 ) 

	start_tools;;


		* ) erofs_ext4_main;;
	    esac
	done
}

merge_main() {
	merge_oplus() {
		clear
		if [[ -f $DIRIN/system_file_contexts ]] && [[ -f $DIRIN/system_fs_config ]]; then
		   merge() {
		     if [[ -f $DIRIN/${partition}_file_contexts ]] && [[ -f $DIRIN/${partition}_fs_config ]]; then
		     	echo ""
		     	echo "Merging $partition fs config & file contexts to system"
		     	echo ""
			gawk -i inplace 'NR>1' $DIRIN/${partition}_file_contexts

			python3 $OPLUSMERGE/$partition.py $DIRIN/${partition}_file_contexts
			python3 $OPLUSMERGE/$partition.py $DIRIN/${partition}_fs_config

			cat $DIRIN/${partition}_file_contexts >> $DIRIN/system_file_contexts
			cat $DIRIN/${partition}_fs_config >> $DIRIN/system_fs_config
		     else
		     	echo ""
		     	echo -e "${R}There's no $partition file contexts and/or fs config supplied ${NC}"
		     	echo ""
		     fi
		   }
		   
		   for partition in $oplus_partitions
		   do
		     merge
		   done

		   rm -rf $DIRIN/my_*
		   mv $DIRIN/system_file_contexts $DIROUT/
		   mv $DIRIN/system_fs_config $DIROUT/
			
		echo "merged all fs context and config.. Output : $DIROUT"

		else
			echo -e "${R}Error: put your system_file_contexts & system_fs_config to $DIRIN"
			echo -e "${NC}"
			
		fi
	}

	merge_non_dynamic() {
		clear
		if [[ -f $DIRIN/system_file_contexts ]] && [[ -f $DIRIN/system_fs_config ]] && [[ -f $DIRIN/system_ext_file_contexts ]] && [[ -f $DIRIN/system_ext_fs_config ]] && [[ -f $DIRIN/product_file_contexts ]] && [[ -f $DIRIN/product_fs_config ]]; then
			gawk -i inplace 'NR>1' $DIRIN/system_ext_file_contexts
			gawk -i inplace 'NR>1' $DIRIN/product_file_contexts

			python3 $MERGE/system_ext.py $DIRIN/system_ext_file_contexts
			python3 $MERGE/system_ext.py $DIRIN/system_ext_fs_config

			python3 $MERGE/product.py $DIRIN/product_file_contexts
			python3 $MERGE/product.py $DIRIN/product_fs_config


			cat $DIRIN/system_ext_file_contexts >> $DIRIN/system_file_contexts
			cat $DIRIN/system_ext_fs_config >> $DIRIN/system_fs_config

			cat $DIRIN/product_file_contexts >> $DIRIN/system_file_contexts
			cat $DIRIN/product_fs_config >> $DIRIN/system_fs_config


			rm -rf $DIRIN/product*
			rm -rf $DIRIN/system_ext*
			mv $DIRIN/system_file_contexts $DIROUT/
			mv $DIRIN/system_fs_config $DIROUT/

		else
			echo -e "${R}Error: you probably missed some important partitions fs conf and context..."
			echo -e "${NC}"
			
		fi
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Merge OPLUS my_* partition to system"
	    echo "2. Merge product and system_ext to system"
	    echo "3. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	merge_oplus
	restart_tool;;

		2 ) 

	merge_non_dynamic
	restart_tool;;

		3 ) 

	start_tools;;


		* ) merge_main;;
	    esac
	done
}

mount_main() {
	mount_normal() {
		OPTIONS=loop
		clear
		if [[ -f $DIRROM/system_a.img ]] || [[ -f $DIRROM/vendor_a.img ]] || [[ -f $DIRROM/odm_a.img ]] || [[ -f $DIRROM/product_a.img ]] || [[ -f $DIRROM/system_ext_a.img ]]; then
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/${partition}_a.img $DIRROM/$partition >> /dev/null 2>&1
			done
		else
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/$partition.img $DIRROM/$partition >> /dev/null 2>&1
			done
		fi
		give_perm
	}

	mount_resize() {
		clear
		bash $DIRSCRIPTS/bin/resizeimg
		give_perm
	}

	mount_ro() {
		OPTIONS=ro,nosuid,nodev,relatime,uhelper=udisks2,loop
		clear
		if [[ -f $DIRROM/system_a.img ]] || [[ -f $DIRROM/vendor_a.img ]] || [[ -f $DIRROM/odm_a.img ]] || [[ -f $DIRROM/product_a.img ]] || [[ -f $DIRROM/system_ext_a.img ]]; then
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/${partition}_a.img $DIRROM/$partition >> /dev/null 2>&1
			done
		else
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/$partition.img $DIRROM/$partition >> /dev/null 2>&1
			done
		fi
		give_perm
	}
	
	while true; do
	    banner
	    echo " "
	    echo "1. Mount raw image and resize"
	    echo "2. Mount without resizing"
	    echo "3. Mount read only"
	    echo "4. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	mount_resize
	restart_tool;;

		2 ) 
	   
	mount_normal
	restart_tool;;

		3 ) 
	   
	mount_ro
	restart_tool;;

		4 ) 

	start_tools;;


		* ) mount_main;;
	    esac
	done
}

payload() {
	clear
	if [ -f $DIRIN/payload.bin ]; then

		$DIRSCRIPTS/bin/payload --output=$DIROUT $DIRIN/payload.bin

		echo " "
		echo "cleaning..."

		rm -rf $DIRIN/payload.bin

		echo " "
		echo "Done! Output : $DIROUT"

	else

		echo -e "${R}there's no payload.bin in $DIRIN"
		echo -e "${NC}"

	fi
}


custom_scripts() {
	clear
	banner
	echo ""
	echo "Choose which script to run :"
	ls -1 $DIRSCRIPTS/custom_scripts | awk '{print NR, $0}'
	echo "x. Back to main menu"
	read
	CHOOSE=$REPLY
	if [[ $CHOOSE == "x" ]]; then
	   start_tools
	else
	   SCRIPT=$(ls -1 $DIRSCRIPTS/custom_scripts | awk '{print NR, $0}' | grep $CHOOSE | awk '{print $2}')
	   exec $DIRSCRIPTS/custom_scripts/$SCRIPT
	fi
	
}

raw_sparse() {
	clear
	echo " "
	echo "Input image/partition name :"
	read
	imgname=$REPLY

	if [ -f $DIRIN/$imgname.img ]; then

		echo " "
		echo "Converting raw image to sparse..."

		img2simg $DIRIN/$imgname.img $DIROUT/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img

		echo " "
		echo "Done! Output : $DIROUT"

	else
		echo -e "${R}there's no $imgname.img in $DIRIN"
		echo -e "${NC}"
	fi
}

raw_datbr() {
	clear
	echo " "
	echo "Input image/partition name :"
	read
	imgname=$REPLY

	if [ -f $DIRIN/$imgname.img ]; then

		echo " "
		echo "Input Brotli compression level (0-11) :"
		read
		COMPLVL=$REPLY

		echo " " 
		echo "converting image : $imgname to sparse"
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img

		echo " " 
		echo "converting image : $imgname to new.dat"
		python3 $DIRSCRIPTS/bin/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.sparse.img
		mv $DIRIN/system.new.dat $DIROUT/$imgname.new.dat
		mv $DIRIN/system.patch.dat $DIROUT/$imgname.patch.dat
		mv $DIRIN/system.transfer.list $DIROUT/$imgname.transfer.list
		rm -rf $DIRIN/system.*

		echo " " 
		echo "compressing image : $imgname using brotli..."

		brotli -q $COMPLVL $DIROUT/$imgname.new.dat
		echo " "
		echo "cleaning..."

		rm -rf $DIROUT/$imgname.new.dat
		echo " "
		echo "Done! Output : $DIROUT"
		
	else
		echo -e "${R}there's no $imgname.img in $DIRIN"
		echo -e "${NC}"
	fi
}

splits_main() {
	splits_compress() {
		clear
		dynamic_part_op_list=$DIROUT/dynamic_partitions_op_list
		SUPERSIZE=9124708352


		a_dp_op_list() {
			if [ -f $dynamic_part_op_list ]; then
				rm -f $dynamic_part_op_list;
			fi;
			
			touch $DIROUT/dynamic_partitions_op_list
			echo "# Remove all existing dynamic partitions and groups before applying full OTA" >> $dynamic_part_op_list
			echo "remove_all_groups" >>  $dynamic_part_op_list
			echo "# Add group qti_dynamic_partitions with maximum size $SUPERSIZE" >>  $dynamic_part_op_list
			echo "add_group qti_dynamic_partitions $SUPERSIZE" >>  $dynamic_part_op_list
			echo "# Add partition system to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add system qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition vendor to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add vendor qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition product to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add product qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition odm to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add odm qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition system_ext to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add system_ext qti_dynamic_partitions" >>  $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Add partition mi_ext to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "add mi_ext qti_dynamic_partitions" >>  $dynamic_part_op_list
			fi
			echo "# Grow partition system from 0 to $SYSTEMSIZE" >>  $dynamic_part_op_list
			echo "resize system $SYSTEMSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition vendor from 0 to $VENDORSIZE" >>  $dynamic_part_op_list
			echo "resize vendor $VENDORSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition product from 0 to $PRODUCTSIZE" >>  $dynamic_part_op_list
			echo "resize product $PRODUCTSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition odm from 0 to $ODMSIZE" >>  $dynamic_part_op_list
			echo "resize odm $ODMSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition system_ext from 0 to $SYSEXTSIZE" >>  $dynamic_part_op_list
			echo "resize system_ext $SYSEXTSIZE" >>  $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Grow partition mi_ext from 0 to $MIEXTSIZE" >>  $dynamic_part_op_list
			   echo "resize mi_ext $MIEXTSIZE" >>  $dynamic_part_op_list
			fi
		}

		ab_dp_op_list() {
			if [ -f $dynamic_part_op_list ]; then
				rm -f $dynamic_part_op_list;
			fi;
			
			touch $DIROUT/dynamic_partitions_op_list
			echo "# Remove all existing dynamic partitions and groups before applying full OTA" >> $dynamic_part_op_list
			echo "remove_all_groups" >> $dynamic_part_op_list
			echo "# Add group qti_dynamic_partitions_a with maximum size $SUPERSIZE" >> $dynamic_part_op_list
			echo "add_group qti_dynamic_partitions_a $SUPERSIZE" >> $dynamic_part_op_list
			echo "# Add group qti_dynamic_partitions_b with maximum size $SUPERSIZE" >> $dynamic_part_op_list
			echo "add_group qti_dynamic_partitions_b $SUPERSIZE" >> $dynamic_part_op_list
			echo "# Add partition system_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add system_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition system_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add system_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition system_ext_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add system_ext_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition system_ext_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add system_ext_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition product_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add product_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition product_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add product_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition vendor_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add vendor_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition vendor_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add vendor_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition odm_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add odm_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition odm_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add odm_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Add partition mi_ext_a to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "add mi_ext_a qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "# Add partition mi_ext_b to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "add mi_ext_b qti_dynamic_partitions" >>  $dynamic_part_op_list
			fi
			echo "# Grow partition system_a from 0 to $SYSTEMSIZE" >> $dynamic_part_op_list
			echo "resize system_a $SYSTEMSIZE" >> $dynamic_part_op_list
			echo "# Grow partition system_ext_a from 0 to $SYSEXTSIZE" >> $dynamic_part_op_list
			echo "resize system_ext_a $SYSEXTSIZE" >> $dynamic_part_op_list
			echo "# Grow partition product_a from 0 to $PRODUCTSIZE" >> $dynamic_part_op_list
			echo "resize product_a $PRODUCTSIZE" >> $dynamic_part_op_list
			echo "# Grow partition vendor_a from 0 to $VENDORSIZE" >> $dynamic_part_op_list
			echo "resize vendor_a $VENDORSIZE" >> $dynamic_part_op_list
			echo "# Grow partition odm_a from 0 to $ODMSIZE" >> $dynamic_part_op_list
			echo "resize odm_a $ODMSIZE" >> $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Grow partition mi_ext_a from 0 to $MIEXTSIZE" >>  $dynamic_part_op_list
			   echo "resize mi_ext_a $MIEXTSIZE" >>  $dynamic_part_op_list
			fi
		}

		brotli_lvl() {
			echo " "
			echo "Input Brotli compression level (0-11) :"
			read
			COMPLVL=$REPLY
		}

		sparse() {
		    if [[ -f $DIRIN/$partition.img ]]; then
			echo ""
			echo "converting $partition into sparse"
			img2simg $DIRIN/$partition.img $DIRIN/$partition.sparse.img >> /dev/null 2>&1
			rm -rf $DIRIN/$partition.img
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.img supplied! skipping...${NC}"
		    fi
		}

		img2sdat() {
		    if [[ -f $DIRIN/$partition.sparse.img ]]; then
			echo " "
			echo "converting $partition into new.dat"
			python3 $DIRSCRIPTS/bin/img2sdat.py $DIRIN/$partition.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
			mv $DIRIN/system.new.dat $DIROUT/$partition.new.dat
			mv $DIRIN/system.patch.dat $DIROUT/$partition.patch.dat
			mv $DIRIN/system.transfer.list $DIROUT/$partition.transfer.list
			rm -rf $DIRIN/system.*
			rm -rf $DIRIN/$partition.*
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.sparse.img supplied! skipping...${NC}"
		    fi
		}

		datbr() {
		    if [[ -f $DIROUT/$partition.new.dat ]]; then
			echo " " 
			echo "compressing $partition using brotli..."
			brotli -q $COMPLVL $DIROUT/$partition.new.dat
			rm -rf $DIROUT/$partition.new.dat
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.new.dat supplied! skipping...${NC}"
		    fi
		}

		compress() {
			echo "========================================="

			for partition in $partitions
			do
			  sparse
			done
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   partition=mi_ext
			   sparse
			fi

			echo " "
			echo "========================================="

			for partition in $partitions
			do
			  img2sdat
			done
			if [[ -f $DIRIN/mi_ext.sparse.img ]]; then
			   partition=mi_ext
			   img2sdat
			fi

			echo " "
			echo "========================================="

			for partition in $partitions
			do
			  datbr
			done
			if [[ -f $DIROUT/mi_ext.new.dat ]]; then
			   partition=mi_ext
			   datbr
			fi

			echo " "
			echo "========================================="
			echo " "
			echo "Done! Output : $DIROUT"

		}
		if [[ ! -f $DIRIN/system.img ]]; then
			touch $DIRIN/system.img
		fi
		if [[ ! -f $DIRIN/vendor.img ]]; then
			touch $DIRIN/vendor.img
		fi
		if [[ ! -f $DIRIN/odm.img ]]; then
			touch $DIRIN/odm.img
		fi
		if [[ ! -f $DIRIN/product.img ]]; then
			touch $DIRIN/product.img
		fi
		if [[ ! -f $DIRIN/system_ext.img ]]; then
			touch $DIRIN/system_ext.img
		fi
		if [[ ! -f $DIRIN/mi_ext.img ]]; then
			touch $DIRIN/mi_ext.img
		fi
		
		ODMSIZE=$(ls -nl $DIRIN/odm.img | awk '{print $5}')
		PRODUCTSIZE=$(ls -nl $DIRIN/product.img | awk '{print $5}')
		SYSTEMSIZE=$(ls -nl $DIRIN/system.img | awk '{print $5}')
		SYSEXTSIZE=$(ls -nl $DIRIN/system_ext.img | awk '{print $5}')
		VENDORSIZE=$(ls -nl $DIRIN/vendor.img | awk '{print $5}')
		if [[ -f $DIRIN/mi_ext.img ]]; then
		    MIEXTSIZE=$(ls -nl $DIRIN/mi_ext.img | awk '{print $5}')
		fi
			
		TOTALSIZE=$(( $ODMSIZE + $PRODUCTSIZE + $SYSTEMSIZE + $SYSEXTSIZE + $VENDORSIZE ))
		
		if [[ $SYSTEMSIZE == 0 ]]; then
			rm -rf $DIRIN/system.img
		fi
		if [[ $VENDORSIZE == 0 ]]; then
			rm -rf $DIRIN/vendor.img
		fi
		if [[ $ODMSIZE == 0 ]]; then
			rm -rf $DIRIN/odm.img
		fi
		if [[ $PRODUCTSIZE == 0 ]]; then
			rm -rf $DIRIN/product.img
		fi
		if [[ $SYSEXTSIZE == 0 ]]; then
			rm -rf $DIRIN/system_ext.img
		fi
		if [[ $MIEXTSIZE == 0 ]]; then
			rm -rf $DIRIN/mi_ext.img
		fi

		if (( $TOTALSIZE > $SUPERSIZE )); then
			echo "Total size of all partitions exceeds max super size, aborting..."
			echo "($TOTALSIZE/$SUPERSIZE)"
			echo ""
		else
			echo "Splits total size :"
			echo "($TOTALSIZE/$SUPERSIZE)"
			echo ""
			while true; do
			    echo "Compiling for A only device or Virtual A/B?"
			    echo "(1) A only"
			    echo "(2) Virtual A/B "
			    read -p "choose 1 or 2 : " choose
			    case $choose in
				[1]* ) 
			echo "Make sure to input your raw .img's to rom_input folder"
			echo " "
			echo "Compiling splits with A only format"
			echo " "

			brotli_lvl
			a_dp_op_list
			compress
			break;;

				[2]* ) 
			echo "Make sure to input your raw .img's to rom_input folder"
			echo " "
			echo "Compiling splits with Virtual A/B format"
			echo " "

			brotli_lvl
			ab_dp_op_list
			compress
			break;;
			
				* ) echo "Please answer 1 or 2.";;
			    esac
			done
		fi
	}

	splits_decompress() {
		clear
		datbr() {
		    if [[ -f $DIRIN/$partition.new.dat.br ]]; then
			echo " "
			echo "Decompressing $partition using brotli..."
			brotli -d $DIRIN/$partition.new.dat.br
			rm -rf $DIRIN/$partition.new.dat.br
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.new.dat.br supplied! skipping...${NC}"
		    fi
		}

		sdat2img() {
		    if [[ -f $DIRIN/$partition.new.dat ]] && [[ -f $DIRIN/$partition.transfer.list ]]; then
			echo " "
			echo "Converting $partition.new.dat to $partition.img (raw)"
			python3 $DIRSCRIPTS/bin/sdat2img.py $DIRIN/$partition.transfer.list $DIRIN/$partition.new.dat $DIROUT/$partition.img >> /dev/null 2>&1
			rm -rf $DIRIN/$partition.*
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.new.dat and/or $partition.transfer.list supplied! skipping...${NC}"
		    fi
		}

		echo "========================================="

		for partition in $partitions
		do
		  datbr
		done
		if [[ -f $DIRIN/mi_ext.new.dat.br ]]; then
		   partition=mi_ext
		   datbr
		fi

		echo " "
		echo "========================================="

		for partition in $partitions
		do
		  sdat2img
		done
		if [[ -f $DIRIN/mi_ext.new.dat ]]; then
		   partition=mi_ext
		   sdat2img
		fi

		echo " "
		echo "========================================="
		echo " "
		echo "Done! Output : $DIROUT"
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Repack Splits (raw to dat.br)"
	    echo "2. Unpack Splits"
	    echo "3. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	splits_compress
	restart_tool;;

		2 ) 
	   
	splits_decompress
	restart_tool;;

		3 ) 

	start_tools;;


		* ) splits_main;;
	    esac
	done
}

sparse_raw() {
	clear
	echo " "
	echo "Input image/partition name :"
	read
	imgname=$REPLY
	if [ -f $DIRIN/$imgname.* ]; then

		echo " "
		echo "Converting sparse to raw image..."

		if [ -f $DIRIN/*.sparse.img ]; then

			img2img $DIRIN/$imgname.sparse.img $DIROUT/$imgname.img >> /dev/null 2>&1

			rm -rf $DIRIN/*

			echo " "
			echo "Done! Output : $DIROUT"

		else

			simg2img $DIRIN/$imgname.img $DIROUT/$imgname.img >> /dev/null 2>&1

			rm -rf $DIRIN/*

			echo " "
			echo "Done! Output : $DIROUT"

		fi
	else
		echo -e "${R}there's no image named $imgname.img or $imgname.sparse.img in $DIRIN"
		echo -e "${NC}"
	fi
}

super_main() {
	super_u_raw() {
		clear
		echo " "
		echo " "
		echo "Input Super image name :"
		read
		imgname=$REPLY

		if [ -f $DIRIN/$imgname.img ]; then

			echo " "
			echo "Unpacking $imgname.img..."
			mkdir $DIRSUPER/config
			lpdump --slot=0 $DIRIN/$imgname.img > $DIRSUPER/config/super_config.txt
			lpunpack $DIRIN/$imgname.img $DIRROM/super >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.*

			echo " "
			echo "Done! Output : $DIRROM/super"

		else

			echo -e "${R}there's no image "$imgname.img""
			echo -e "${NC}"
		fi
	}
	
	super_u_zstd() {
		clear
		echo " "
		echo "Input file name :"
		read
		filename=$REPLY
		
		if [ -f $DIRIN/$filename ]; then
			mv $DIRIN/$filename $DIRIN/$filename.zst
			
			echo " "
			echo "Decompressing $filename (zstd)"
			zstd -d $DIRIN/$filename.zst -o $DIRIN/super.img
			rm -rf $DIRIN/$filename.*

			echo " "
			echo "Unpacking super..."
			mkdir $DIRSUPER/config
			lpdump --slot=0 $DIRIN/super.img > $DIRSUPER/config/super_config.txt
			lpunpack $DIRIN/super.img $DIRROM/super >> /dev/null 2>&1
			rm -rf $DIRIN/super.img

			echo " "
			echo "Done! Output : $DIRROM/super"

		else

			echo -e "${R}there's no file named "$filename" in $DIRIN"
			echo -e "${NC}"
		fi
	}

	super_u_datbr() {
		clear
		echo " "
		echo " "
		echo "Input Super image name :"
		read
		imgname=$REPLY

		if [ -f $DIRIN/$imgname.new.dat.br ]; then

			echo "Decompressing brotli..."
			brotli -d $DIRIN/$imgname.new.dat.br
			rm -rf $DIRIN/$imgname.new.dat.br

			echo " "
			echo "Converting $imgname.new.dat to $imgname.img (raw)..."
			python3 $DIRSCRIPTS/bin/sdat2img.py $DIRIN/$imgname.transfer.list $DIRIN/$imgname.new.dat $DIROUT/$imgname.img >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.*

			echo " "
			echo "Unpacking $imgname.img..."
			mkdir $DIRSUPER/config
			lpdump --slot=0 $DIROUT/$imgname.img > $DIRSUPER/config/super_config.txt
			lpunpack $DIROUT/$imgname.img $DIRROM/super >> /dev/null
			rm -rf $DIROUT/$imgname.*

			echo " "
			echo "Done! Output : $DIRROM/super"

		else

			echo -e "${R}theres no image "$imgname.new.dat.br""
			echo -e "${NC}"
		fi
	}

	super_r() {
		meta_size=$(cat $DIRSUPER/config/super_config.txt | awk '/Metadata max size:/ { print $4 }')
		meta_slot=$(cat $DIRSUPER/config/super_config.txt | awk '/Metadata slot count:/ { print $4 }')
		size_super=$(cat $DIRSUPER/config/super_config.txt | awk '/Size:/ { print $2 }')
		first_sector=$(cat $DIRSUPER/config/super_config.txt | awk '/First sector:/ { print ($3 * 512)}')
		group_table=$(cat $DIRSUPER/config/super_config.txt | grep -A10 "Group table:" | grep "Name:" | awk '{ print $2 }' | sed -n "2p")
		max_size_super=$(cat $DIRSUPER/config/super_config.txt | grep -A11 "Group table:" | grep "Maximum size:" | awk '{ print $3 }' | sed -n "2p")
		group_table2=$(cat $DIRSUPER/config/super_config.txt | grep -A10 "Group table:" | grep "Name:" | awk '{ print $2 }' | sed -n "3p")
		max_size_super2=$max_size_super
		
		configsize=$(du -s -b $DIRSUPER/config | awk '{print $1}')
		superdirsize=$(du -s -b $DIRSUPER | awk '{print $1}')
		TOTALSIZE=$(( $superdirsize - $configsize ))
		
		clear
		echo " "
		echo "Input Raw Super image name :"
		read
		imgname=$REPLY
		echo " "
		while true; do
		    read -p "Your super raw img name is : $imgname is that correct? (Y/N)" yn
		    case $yn in
			[Yy]* ) break;;
			[Nn]* ) restart_tool;;
			* ) echo "Please answer yes or no.";;
		    esac
		done
		
		while true; do
		   echo ""
		   echo "Compress image to :"
		   echo "1. raw"
		   echo "2. sparse"
		   echo "3. new.dat"
		   echo "4. dat.br"
		   echo "5. zstd"
		   read -p "" choose
		   case $choose in
			[1]* ) 
				COMPRESSION=raw
				break;;
			[2]* )
				COMPRESSION=sparse
				break;;
			[3]* )
				COMPRESSION=dat
				break;;
			[4]* )
				COMPRESSION=br
				echo " "
				echo "Input Brotli compression level (0-11) :"
				read
				COMPLVL=$REPLY
				break;;
			[5]* )
				COMPRESSION=zstd
				echo " "
				echo "Input zstd suffix (leave it empty if you want .zst) :"
				read
				ZSTDSUFFIX=.$REPLY
				if [[ $ZSTDSUFFIX == "." ]]; then
					ZSTDSUFFIX=.zst
				elif [[ $ZSTDSUFFIX == ". " ]]; then
					ZSTDSUFFIX=""
				fi
				echo " "
				echo "Input zstd compression lvl (1-19) :"
				read
				ZSTDLVL=$REPLY
				break;;
					
			* ) echo "Please answer with one of the above selections.";;
		   esac
		done

		if [[ $meta_slot == 2 ]]; then
			echo " "
			echo "A only detected..."
			echo "Compiling super with A only format"
			echo " "

			part_list=$(cat $DIRSUPER/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }')
			
			if (( $TOTALSIZE > $max_size_super )); then
				echo "Total size of all partitions exceeds max super size, aborting..."
				echo "($TOTALSIZE/$max_size_super)"
				echo ""
			else
				echo "Super total size :"
				echo "($TOTALSIZE/$max_size_super)"
				echo ""
				echo "Compiling super : $imgname.img (raw)..."
				
				echo "#!/bin/bash" > $DIRSCRIPTS/build_super.sh
				echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot --device=super:$size_super:$first_sector --group=$group_table:$max_size_super '\'" >> $DIRSCRIPTS/build_super.sh

				for partition in $part_list; do
				   partition_size=$(ls -nl $DIRSUPER/$partition.img | awk '{print $5}')
				   echo "--partition=$partition:none:$partition_size:$group_table --image=$partition=$DIRSUPER/$partition.img '\'" >> $DIRSCRIPTS/build_super.sh
				done

				echo "--output=$DIRIN/$imgname.img" >> $DIRSCRIPTS/build_super.sh
				echo "exit" >> $DIRSCRIPTS/build_super.sh
				
				sed -i "s/[']//g" $DIRSCRIPTS/build_super.sh
				chmod 755 $DIRSCRIPTS/build_super.sh
				$DIRSCRIPTS/build_super.sh
				
				rm -rf $DIRSCRIPTS/build_super.sh
				rm -rf $DIRSUPER/*
			fi
		else
			echo " "
			echo "Virtual A/B detected..."
			echo "Compiling super with Virtual A/B format"
			echo " "
			while true; do
			    echo "Choose which slot is active"
			    echo "1. A"
			    echo "2. B"
			    read -p "" choose
			    case $choose in
				[1]* ) 
					slot=_a
					emptyslot=_b
					break;;
				[2]* )
					slot=_b
					emptyslot=_a
					break;;
				* ) echo "Please answer 1 or 2.";;
			    esac
			done
			
			ab_part_list=$(cat $DIRSUPER/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }' | grep ${slot})
			ab_part_list_empty=$(cat $DIRSUPER/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }' | grep ${emptyslot})
			
			if (( $TOTALSIZE > $max_size_super )); then
				echo "Total size of all partitions exceeds max super size, aborting..."
				echo "($TOTALSIZE/$max_size_super)"
				echo ""
			else
				echo "Super total size :"
				echo "($TOTALSIZE/$max_size_super)"
				echo ""
				echo "Compiling super : $imgname.img (raw)..."
				
				echo "#!/bin/bash" > $DIRSCRIPTS/build_super.sh
				echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot --device=super:$size_super:$first_sector --group=$group_table:$max_size_super --group=$group_table2:$max_size_super2 '\'" >> $DIRSCRIPTS/build_super.sh
				for partition in $ab_part_list; do
				   partition_size=$(ls -nl $DIRSUPER/$partition.img | awk '{print $5}')
				   echo "--partition=$partition:none:$partition_size:$group_table --image=$partition=$DIRSUPER/$partition.img '\'" >> $DIRSCRIPTS/build_super.sh
				done
				echo "--output=$DIRIN/$imgname.img" >> $DIRSCRIPTS/build_super.sh
				
				echo "touch $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super.sh
				for emptypartition in $ab_part_list_empty; do
				   echo "lpadd $DIRIN/$imgname.img $emptypartition $group_table2 $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super.sh
				done
				echo "rm -rf $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super.sh
				echo "exit" >> $DIRSCRIPTS/build_super.sh
				
				sed -i "s/[']//g" $DIRSCRIPTS/build_super.sh
				chmod 755 $DIRSCRIPTS/build_super.sh
				$DIRSCRIPTS/build_super.sh
				
				rm -rf $DIRSCRIPTS/build_super.sh
				rm -rf $DIRSUPER/*
			fi
		fi


		if [[ $COMPRESSION == raw ]]; then
			echo " "
			mv $DIRIN/$imgname.img $DIROUT/$imgname.img
			echo "super build done! Output : $DIROUT"
		elif [[ $COMPRESSION == sparse ]]; then
			echo " "
			echo "Converting raw $imgname.img to sparse..."
			img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.img
			mv $DIRIN/$imgname.sparse.img $DIROUT/$imgname.sparse.img
			echo "compession done! Output : $DIROUT"
		elif [[ $COMPRESSION == dat ]]; then	
			echo " "
			echo "Converting raw $imgname.img to sparse..."
			img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.img
			
			echo " "
			echo "Converting $imgname.img (sparse) to $imgname.new.dat..."
			python3 $DIRSCRIPTS/bin/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.*
			mv $DIRIN/system.new.dat $DIROUT/$imgname.new.dat
			mv $DIRIN/system.patch.dat $DIROUT/$imgname.patch.dat
			mv $DIRIN/system.transfer.list $DIROUT/$imgname.transfer.list
			rm -rf $DIRIN/$imgname.*
			echo "compession done! Output : $DIROUT"
		elif [[ $COMPRESSION == br ]]; then
			echo " "
			echo "Converting raw $imgname.img to sparse..."
			img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.img
			
			echo " "
			echo "Converting $imgname.img (sparse) to $imgname.new.dat..."
			python3 $DIRSCRIPTS/bin/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
			rm -rf $DIRIN/$imgname.*
			mv $DIRIN/system.new.dat $DIROUT/$imgname.new.dat
			mv $DIRIN/system.patch.dat $DIROUT/$imgname.patch.dat
			mv $DIRIN/system.transfer.list $DIROUT/$imgname.transfer.list
			rm -rf $DIRIN/$imgname.*
			
			echo " "
			echo "Compressing to $imgname.new.dat.br..."
			brotli -q $COMPLVL $DIROUT/$imgname.new.dat
			echo " "
			echo "cleaning..."
			echo " "
			rm -rf $DIROUT/$imgname.new.dat
			echo "compession done! Output : $DIROUT"
		elif [[ $COMPRESSION == zstd ]]; then
			echo " "
			echo "Compressing $imgname.img to ${imgname}$ZSTDSUFFIX (zstd)"
			zstd -${ZSTDLVL} $DIRIN/$imgname.img -o $DIROUT/${imgname}$ZSTDSUFFIX
			rm -rf $DIRIN/$imgname.img
			echo " "
			echo "super build done! Output : $DIROUT"
		fi
	}
	
	while true; do
	    banner
	    echo " "
	    echo "1. Repack Super (raw, sparse, .dat, .br, zstd)"
	    echo "2. Unpack Super (dat.br)"
	    echo "3. Unpack Super (zstd)"
	    echo "4. Unpack Super (raw)"
	    echo "5. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	super_r
	restart_tool;;

		2 ) 
	   
	super_u_datbr
	restart_tool;;

		3 ) 
		
	super_u_zstd
	restart_tool;;
	
		4 ) 
		
	super_u_raw
	restart_tool;;

		5 ) 
	   
	start_tools;;


		* ) super_main;;
	    esac
	done
}

umount_main() {
	umount_resize_freespace() {
		clear
		resize_to_build(){
			if [ -f $DIRROM/${valset}_a.img ]; then
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
				
				vsizenow=$(ls -nl $DIRROM/${valset}_a.img | awk '{print $5}')
				sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
				sudo resize2fs $DIRROM/${valset}_a.img $sizeimg
				sudo e2fsck -yf $DIRROM/${valset}_a.img
			else
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
				
				vsizenow=$(ls -nl $DIRROM/${valset}.img | awk '{print $5}')
				sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
				sudo resize2fs $DIRROM/${valset}.img $sizeimg > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
			fi;
		}

		echo " "
		echo "Input partition that you want to unmount :"
		read
		PARTITION=$REPLY

		if [[ $PARTITION == "system" ]] || [[ $PARTITION == "system_ext" ]] || [[ $PARTITION == "product" ]] || [[ $PARTITION == "odm" ]] || [[ $PARTITION == "vendor" ]]; then

			echo " "
			echo "Input partiton free space in mb (megabytes) :"
			read
			FREESPACE=$REPLY
			
			echo " "
			echo "Unmounting $PARTITION..."
			echo " "
			restore_perm > /dev/null 2>&1
			sudo umount $DIRROM/$PARTITION >> /dev/null 2>&1

			echo "Resizing $PARTITION..."
			echo " "
			# Resize image to minimum
			valset=$PARTITION
			resize_to_build
		else
			echo -e "${R}there's no partition named : $PARTITION"
			echo -e "${NC}"
		fi
	}
	umount_resize() {
		clear
		resize_to_build(){
			if [ -f $DIRROM/${valset}_a.img ]; then
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
			else
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
			fi;
		}
		echo " "
		echo "Unmounting partitions..."
		echo " "
		restore_perm > /dev/null 2>&1
		for partition in $partitions
		do
	 	 sudo umount $DIRROM/$partition >> /dev/null 2>&1
		done

		echo "Resizing partitions..."
		echo " "
		# Resize image to minimum
		for valset in $partitions
		do
		  resize_to_build
		done
	}
	umount_normal() {
		clear
		echo " "
		echo "Unmounting partitions..."
		echo " "
		restore_perm > /dev/null 2>&1
		for partition in $partitions
		do
	 	 sudo umount $DIRROM/$partition >> /dev/null 2>&1
		done
	}
	
	while true; do
	    banner
	    echo " "
	    echo "1. Umount raw image and resize to smallest size"
	    echo "2. Umount raw image and resize with free space "
	    echo "3. Umount without resizing"
	    echo "4. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	umount_resize
	restart_tool;;

		2 ) 

	umount_resize_freespace
	restart_tool;;

		3 ) 
	   
	umount_normal
	restart_tool;;

		4 ) 

	start_tools;;


		* ) umount_main;;
	    esac
	done
}

zip_main() {
	oplus_zip() {
		ZIPNAME=$DIRTOOLS/oplus.zip
		clear
		cd $DIROUT
		zip $ZIPNAME my_* system.img vendor.img odm.img product.img system_ext.img
		cd $DIRTOOLS
	}
	splits_zip() {
		ZIPNAME=$DIRTOOLS/split-partition.zip
		clear
		cd $DIROUT
		zip $ZIPNAME dynamic_partitions_op_list system.* vendor.* odm.* product.* system_ext.*
		cd $DIRTOOLS
	}
	
	while true; do
	    banner
	    echo " "
	    echo "*this will zip files in rom_output folder*"
	    echo " "
	    echo "1. Zip Oplus images"
	    echo "2. Zip Compressed Split partitions"
	    echo "3. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	oplus_zip
	restart_tool;;

		2 ) 
	   
	splits_zip
	restart_tool;;

		3 ) 
	   
	start_tools;;

		* ) zip_main;;
	    esac
	done
}

patch_oplus() {
	DIRPATCH=$DIRTOOLS/scripts/patch
	patch_device() {
		clear
		echo ""
		echo "patching for device : $device"
		
		rm -rf $DIRROM/system/my_product/priv-app/*
		cp $DIRPATCH/${device}/HotwordEnrollmentOKGoogleHEXAGON.apk $DIRROM/system/my_product/priv-app/
		cp $DIRPATCH/${device}/HotwordEnrollmentXGoogleHEXAGON.apk $DIRROM/system/my_product/priv-app/
		chmod 644 $DIRROM/system/my_product/priv-app/*
		
		rm -rf $DIRROM/system/my_product/etc/permissions/com.oplus.feature.enable.oemports10t.xml
		
		rm -rf $DIRROM/system/system/etc/init/hw/init.usb.configfs.rc
		cp $DIRPATCH/${device}/init.usb.configfs.rc $DIRROM/system/system/etc/init/hw/
		chmod 644 $DIRROM/system/system/etc/init/hw/init.usb.configfs.rc
		
		cp $DIRPATCH/${device}/uinput-fpc.kl $DIRROM/system/system/usr/keylayout/
		cp $DIRPATCH/${device}/uinput-goodix.kl $DIRROM/system/system/usr/keylayout/
		chmod 644 $DIRROM/system/system/usr/keylayout/uinput-fpc.kl
		chmod 644 $DIRROM/system/system/usr/keylayout/uinput-goodix.kl
		
		echo "patching done..."
		echo ""
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Patch build for alioth"
	    echo "2. Patch build for munch"
	    echo "3. Back to main menu"
	    read -p "" choose
	    case $choose in
		1 ) 
		device=alioth
		patch_device
		restart_tool;;
		2 )
		device=munch
		patch_device
		restart_tool;;
		3 )
		start_tools;;
		* ) 
		patch_oplus;;
	    esac
	done
}

install_req() {
	while true; do
	    banner
	    echo ""
	    echo "Choose your linux distribution base"
	    echo "1. Arch"
	    echo "2. Redhat"
	    echo "3. Ubuntu"
	    echo "4. Back to main menu"
	    read -p "" choose
	    case $choose in
		1 ) 
		sudo pacman -S android-tools
		sudo pacman -S gawk
		sudo pacman -S erofs-utils
		restart_tool;;
		
		2 )
		sudo dnf install android-tools
		sudo dnf install erofs-utils
		sudo dnf install gawk
		restart_tool;;
		
		3 )
		sudo apt update && sudo apt upgrade
		sudo apt install brotli android-sdk-libsparse-utils gawk wget build-essential libncursesw5-dev libssl-dev \
				 libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev libffi-dev zlib1g-dev
		restart_tool;;
		
		4 )
		start_tools;;
		
		* ) 
		install_req;;
	    esac
	done
}


repack_ext4() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack EXT4 image with old image size"
	    echo "2. Repack EXT4 image with folder size"
	    echo "3. Repack EXT4 image and manually input size"
	    echo "4. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	repack_ext4_img_samesize
	restart_tool;;

		2 ) 
	   
	repack_ext4_img_foldersize
	restart_tool;;
	
		3 ) 
	   
	repack_ext4_img_inputsize
	restart_tool;;
	
		4 ) 
	   
	start_tools;;


		* ) repack_ext4;;
	    esac
	done
}

unpack_repack_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack EXT4 image"
	    echo "2. Unpack EXT4 image"
	    echo "3. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	repack_ext4
	restart_tool;;

		2 ) 
	   
	unpack_ext4_img
	restart_tool;;

		3 ) 
	   
	start_tools;;


		* ) unpack_repack_main;;
	    esac
	done
}

cd_cv_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Convert dat.br to raw img"
	    echo "2. Convert raw .img to dat.br"
	    echo "3. Convert raw to sparse"
	    echo "4. Convert sparse to raw"
	    echo "5. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	datbr_raw
	restart_tool;;

		2 ) 
	   
	raw_datbr
	restart_tool;;

		3 ) 
	   
	raw_sparse
	restart_tool;;
	
		4 )
		
	sparse_raw
	restart_tool;;

		5 ) 
	   
	start_tools;;


		* ) cd_cv_main;;
	    esac
	done
}

zstd_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Compress zstd"
	    echo "2. Decompress zstd"
	    echo "3. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	compress_zstd
	restart_tool;;

		2 ) 
	   
	decompress_zstd
	restart_tool;;

		3 ) 
	   
	start_tools;;


		* ) unpack_repack_main;;
	    esac
	done
}

start_tools() {
	setup
	while true; do
	    banner
	    echo " "
	    echo "1. Super partition tools"
	    echo "2. Split partition tools (system,vendor,odm,system_ext,product)"
	    echo "3. Convert or compress images"
	    echo "4. Unpack or repack images"
	    echo "5. Convert erofs to ext4"
	    echo "6. Rebuild EXT4 Images (removes avb)"
	    echo "7. Mount raw .img"
	    echo "8. Unmount images"
	    echo "9. Unpack payload.bin"
	    echo "10. Custom Scripts"
	    echo "11. Merge fs context and config to system"
	    echo "12. Patch oplus rom for specific device"
	    echo "13. Auto ZIP"
	    echo "14. Zstd Tools"
	    echo "c. Clean up folders"
	    echo "0. Install proprietary packages"
	    echo "x. Exit tool"
	    
	    read -p "" choose
	    case $choose in
	    
		0 ) 

	install_req
	restart_tool;;

		1 ) 

	super_main
	restart_tool;;

		2 ) 
	   
	splits_main
	restart_tool;;

		3 ) 
		
	cd_cv_main
	restart_tool;;

		4 ) 
		
	unpack_repack_main
	restart_tool;;

		5 ) 
		
	erofs_ext4_main
	restart_tool;;

		6 ) 
		
	rebuild_ext4_single
	restart_tool;;

		7 ) 
		
	mount_main
	restart_tool;;

		8 ) 
		
	umount_main
	restart_tool;;

		9 ) 
		
	payload
	restart_tool;;

		10 ) 
		
	custom_scripts
	restart_tool;;

		11 ) 
		
	merge_main
	restart_tool;;
	
		12 ) 
		
	patch_oplus
	restart_tool;;

		13 ) 
		
	zip_main
	restart_tool;;
	
		14 ) 
		
	zstd_main
	restart_tool;;

		c ) 
		
	clean
	restart_tool;;

		x )  
	clear	
	exit;;
		* ) start_tools;;
	    esac
	done
}
