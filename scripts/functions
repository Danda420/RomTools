#!/bin/bash
DIRTOOLS=$PWD
DIRIN=$DIRTOOLS/rom_input
DIROUT=$DIRTOOLS/rom_output
DIRROM=$DIRTOOLS/ROM
DIRSCRIPTS=$DIRTOOLS/scripts
BIN=$DIRSCRIPTS/bin
MERGE=$BIN/merge_non_dynamic
OPLUSMERGE=$BIN/oplus
DIRSUPER=$DIRROM/super
erofsdir=$DIRROM/erofs
partitions="system vendor odm product system_ext"
oplus_partitions="my_bigball my_carrier my_company my_engineering my_heytap my_manifest my_preload my_product my_region my_stock"
G='\033[1;32m'
R='\033[1;31m'
NC='\033[0m'
LC='\033[1;36m'

restart_tool() {
	echo " "
	while true; do
	   echo "start tools again? (y/n)"
	   read -p "" yn
	   case $yn in
		[Yy]* ) start_tools;;
		[Nn]* ) 
		clear
		exit;;   
		* ) echo "please choose yes or no";;
	    esac
	done
}

banner() {
	clear
	echo -e "${LC}========================="
	echo -e "${LC}   ROM TOOLS FOR LINUX   "
	echo -e "${LC}        by  Danda        "
	echo -e "${LC}=========================${NC}"
}

give_perm() {
	for partition in $partitions
	do
	  sudo chown -R $USER:$USER $DIRROM/$partition >> /dev/null 2>&1
	done
}

restore_perm() {
	for partition in $partitions
	do
		if [[ $partition == vendor ]]; then
			sudo chown -R 0:0 $DIRROM/vendor/
			sudo chown 0:2000 $(sudo find $DIRROM/vendor -type d)
			sudo chown -R 0:2000 $DIRROM/vendor/bin
			sudo chown 0:2000 $DIRROM/vendor/addon/*
		elif [[ $partition == system ]]; then
			sudo chown -R 0:0 $DIRROM/system
			sudo chown -R 0:2000 $DIRROM/system/system/bin
		else
			sudo chown -R 0:0 $DIRROM/$partition
			sudo chown -R 0:2000 $DIRROM/$partition/bin
		fi
	done
}

setup() {
	clear
	if [[ ! -d $DIRTOOLS/ROM ]] && [[ ! -d $DIRTOOLS/rom_input ]] && [[ ! -d $DIRTOOLS/rom_output ]]; then
		mkdir $DIRTOOLS/rom_input \
		      $DIRTOOLS/rom_output \
		      $DIRTOOLS/ROM \
		      $DIRTOOLS/ROM/odm \
		      $DIRTOOLS/ROM/product \
		      $DIRTOOLS/ROM/system \
		      $DIRTOOLS/ROM/system_ext \
		      $DIRTOOLS/ROM/vendor \
		      $DIRTOOLS/ROM/super
		if [[ ! -f /bin/romtools ]]; then
		    echo "#!/bin/bash" > $DIRSCRIPTS/romtools
		    echo "cd $DIRTOOLS" >> $DIRSCRIPTS/romtools
		    echo "$DIRTOOLS/start" >> $DIRSCRIPTS/romtools
		    sudo mv $DIRSCRIPTS/romtools /bin/romtools
		    sudo chmod 755 /bin/romtools
		fi
	fi
}

clean() {
	clear
	echo "cleaning..."

	rm -rf $DIRIN \
	       $DIROUT \
	       $DIRROM
	sudo rm -rf $BIN/__pycache__
	sudo rm -rf $BIN/*.pyc

	echo -e "${G}Done!${NC}"
}

file_selector() {
	selected_dir=$1
	file_extension=$2
	if ls -1 $selected_dir/*$file_extension > /dev/null 2>&1 ; then
	   ls -1 $selected_dir/*$file_extension | sed 's:.*/::' | awk '{print NR ".", $0}'
	else
	   if [[ $file_extension == "" ]]; then
	      echo -e "${R}No file(s) found in $selected_dir ${NC}"
	      echo ""
	   else
	      echo -e "${R}No file(s) found in $selected_dir with $file_extension file extension ${NC}"
	      echo ""
	   fi
	fi
	echo "x. Back to main menu"
	read
	CHOOSE=$REPLY
	if [[ $CHOOSE == "x" ]]; then
	   start_tools
	elif [[ $CHOOSE == "" ]]; then
	   clear
	   banner
	   echo ""
	   file_selector $selected_dir $file_extension
	else
	   if [[ $file_extension == "" ]]; then
	      FILE=$(ls -1 $selected_dir | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}')
	      clear
	      echo "Selected: $FILE"
	   else
	      file1=$(ls -1 $selected_dir/*$file_extension | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}' | sed "s/$file_extension//")
	      file2=${file1%/}
	      file3=${file2##*/}
	      FILE=$file3
	      clear
	      echo "Selected: ${FILE}${file_extension}"
	   fi
	fi
}

extracted_partition_selector() {
	selected_dir=$1
	if ls -1 $selected_dir > /dev/null 2>&1 ; then
	   ls -1 $selected_dir | grep -v "config" | awk '{print NR ".", $0}'
	else
	   echo -e "${R}No extracted partition(s) found! ${NC}"
	   echo ""
	fi
	echo "x. Back to main menu"
	read
	CHOOSE=$REPLY
	if [[ $CHOOSE == "x" ]]; then
	   start_tools
	elif [[ $CHOOSE == "" ]]; then
	   clear
	   banner
	   echo ""
	   extracted_partition_selector $selected_dir
	else
	   FOLDER=$(ls -1 $selected_dir | grep -v "config" | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}')
	   clear
	   echo "Selected: $FOLDER"
	fi
}

resize_img(){
	if [[ $1 == "smallest" ]]; then
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
		sudo resize2fs -M $DIRIMG_RESIZE > /dev/null 2>&1
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
	elif [[ $1 == "freespace" ]]; then
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
		sudo resize2fs -M $DIRIMG_RESIZE > /dev/null 2>&1
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
		vsizenow=$(ls -nl $DIRIMG_RESIZE | awk '{print $5}')
		sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
		sudo resize2fs $DIRIMG_RESIZE $sizeimg > /dev/null 2>&1
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
	fi
}

convert_erofs_ext4(){
	if [[ -f $DIRIN/$image.img ]]; then
		echo " "
		echo "Starting conversion..."
		echo ""
		echo "- Unpacking $image image (erofs)"
	        $BIN/erofs.unpack -i $DIRIN/$image.img -o $erofsdir -x > /dev/null 2>&1
	        
		echo "- Rebuilding $image as ext4 image..."
		foldersize=$(du -s -B1 $erofsdir/$image | awk '{print $1}')
		SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $erofsdir/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		repack_erofs_as_ext4_cmd > /dev/null 2>&1
		DIRIMG_RESIZE=$DIROUT/$image.img
		resize_img smallest
		echo "- Done"
		echo ""
		if [[ -f $DIROUT/$image.img ]]; then
		   rm -rf $DIRIN/$image.img
		   echo -e "${G}Conversion done..."
		   echo -e "Output : $DIROUT/$image.img ${NC}"
		else
		   echo -e "${R}Conversion Failed!"
		   echo -e "${NC}"
		fi
		echo ""
		cd $DIRTOOLS
	else
		echo ""
		echo -e "${R}there's no image named "$image.img" in $DIRIN"
		echo -e "${NC}"
	 fi
}
		
rebuild_ext4(){
	if [[ -f $DIRIN/$partition.img ]]; then
		echo " "
		echo "Starting rebuilding..."
		echo ""
		echo "- Extracting $partition"
		mkdir $DIRROM/rebuildimg
		sudo $BIN/imgextractor.py $DIRIN/$partition.img $DIRROM/rebuildimg > /dev/null 2>&1
		foldersize=$(sudo du -s -B1 $DIRROM/rebuildimg/$partition | awk '{print $1}')
		SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
			SIZE=`sudo du -sk $DIRROM/rebuildimg/$partition | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		echo "- Rebuilding $partition..."
		if [[ $partition == system ]] || [[ $partition == system_a ]] || [[ $partition == system_b ]]; then
			sudo $BIN/make_ext4fs -J -T -1 -S "$DIRROM/rebuildimg/config/$partition/${partition}_file_contexts" -C "$DIRROM/rebuildimg/config/$partition/${partition}_fs_config" -l "$SIZE" -L "/" -a "/$partition" "$DIROUT/$partition.img" "$DIRROM/rebuildimg/$partition" > /dev/null 2>&1
		else
			sudo $BIN/make_ext4fs -J -T -1 -S "$DIRROM/rebuildimg/config/$partition/${partition}_file_contexts" -C "$DIRROM/rebuildimg/config/$partition/${partition}_fs_config" -l "$SIZE" -L "$partition" -a "/$partition" "$DIROUT/$partition.img" "$DIRROM/rebuildimg/$partition" > /dev/null 2>&1
		fi
		DIRIMG_RESIZE=$DIROUT/$partition.img
		resize_img smallest
		sudo rm -rf $DIRROM/rebuildimg
		echo "- Done!"
		echo ""
		if [[ $(ls -l $DIROUT/$partition.img | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIRIN/$partition.img
		   echo -e "${G}Rebuild done..."
		   echo -e "Output : $DIROUT/$partition.img ${NC}"
		else
		   echo -e "${R}Rebuild Failed!"
		   echo -e "${NC}"
		fi
		echo ""
	 else
		echo ""
		echo -e "${R}there's no image named "$partition.img" in $DIRIN"
		echo -e "${NC}"
	fi
}

rebuild_ext4_single() {
		clear
		banner
		echo " "
		echo "choose which image you wanted to rebuild"
		echo " "
		file_selector $DIRIN ".img"
		partition=$FILE
		if [[ $(blkid -o value -s TYPE $DIRIN/$partition.img) == ext4 ]]; then
		   rebuild_ext4
		else
		   echo ""
		   echo -e "${R}$partition.img fs type is $(blkid -o value -s TYPE $DIRIN/$partition.img), aborting..."
		   echo -e "${NC}"
		fi
}

datbr_raw() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to extract"
	echo " "
	file_selector $DIRIN ".new.dat.br"
	imgname=$FILE

	if [ -f $DIRIN/$imgname.new.dat.br ]; then

		echo "Unpacking..."
		echo " "
		brotli -d $DIRIN/$imgname.new.dat.br

		rm -rf $DIRIN/$imgname.new.dat.br

		python3 $BIN/sdat2img.py $DIRIN/$imgname.transfer.list $DIRIN/$imgname.new.dat $DIROUT/$imgname.img  >> /dev/null 2>&1
		echo " "
		echo "Cleaning input folder..."

		rm -rf $DIRIN/$imgname.*

		echo " "
		if [[ -f $DIROUT/$imgname.img ]]; then
		   echo -e "${G}Done! Output : $DIROUT/$imgname.img ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi
}

compress_zstd() {
	clear
	banner
	echo " "
	echo "choose which file you wanted to compress"
	echo " "
	file_selector $DIRIN ""
	filename=$FILE
	
	if [ -f $DIRIN/$filename ]; then
		echo " "
		echo "Input zstd suffix (leave it empty if you want .zst) :"
		read
		ZSTDSUFFIX=.$REPLY
		if [[ $ZSTDSUFFIX == "." ]]; then
			ZSTDSUFFIX=.zst
		elif [[ $ZSTDSUFFIX == ". " ]]; then
			ZSTDSUFFIX=""
		fi
		
		echo " "
		echo "Input zstd compression lvl (1-19) :"
		read
		ZSTDLVL=$REPLY
		
		echo " "
		echo "Compressing $filename to ${filename}$ZSTDSUFFIX (zstd)"
		zstd -${ZSTDLVL} $DIRIN/$filename -o $DIROUT/${filename}$ZSTDSUFFIX
		rm -rf $DIRIN/$filename
		echo " "
		if [[ -f $DIROUT/${filename}$ZSTDSUFFIX ]]; then
		   echo -e "${G}Done! Output : $DIROUT/${filename}$ZSTDSUFFIX ${NC}"
		else
		   echo -e "${R}Compression Failed!"
		   echo -e "${NC}"
		fi
	fi	
}

decompress_zstd() {
	clear
	banner
	echo " "
	echo "choose which file you wanted to decompress"
	echo " "
	file_selector $DIRIN ""
	filename=$FILE
	
	if [ -f $DIRIN/$filename ]; then
		mv $DIRIN/$filename $DIRIN/$filename.zst
		
		echo " "
		echo "Input $filename output name :"
		read
		outputname=$REPLY
		
		echo " "
		echo "Decompressing $filename (zstd)"
		zstd -d $DIRIN/$filename.zst -o $DIROUT/$outputname
		rm -rf $DIRIN/$filename.*
		echo " "
		if [[ -f $DIROUT/$outputname ]]; then
		   echo -e "${G}Done! Output : $DIROUT/$outputname ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi	
}

unpack_ext4() {
	if [[ -f $DIRIN/$image.img ]]; then
	   if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == ext4 ]]; then
		if [[ ! -d $DIRROM/EXT4 ]]; then
			mkdir $DIRROM/EXT4
		fi
		echo ""
		sudo $BIN/imgextractor.py $DIRIN/$image.img $DIRROM/EXT4
		sudo chown -R $USER:$USER $DIRROM/EXT4
		echo ""
		echo -e "${G}Output : $DIRROM/EXT4/$image ${NC}"
		rm -rf $DIRIN/$image.img
	   else
	   	echo ""
		echo -e "${R}$image.img fs type is $(blkid -o value -s TYPE $DIRIN/$image.img), aborting..."
		echo -e "${NC}"
	   fi
	else
		echo -e "${R}Error: no image named $image.img in $DIRIN"
		echo -e "${NC}"
	fi
}

unpack_erofs() {
	if [[ -f $DIRIN/$image.img ]]; then
	   if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == erofs ]]; then
		if [[ ! -d $erofsdir ]]; then
			mkdir $erofsdir
		fi
		echo ""
		$BIN/erofs.unpack -i $DIRIN/$image.img -o $erofsdir -x
		echo ""
		echo -e "${G}Output : $erofsdir/$image ${NC}"
		rm -rf $DIRIN/$image.img
	   else
	   	echo ""
		echo -e "${R}$image.img fs type is $(blkid -o value -s TYPE $DIRIN/$image.img), aborting..."
		echo -e "${NC}"
	   fi
	else
		echo -e "${R}Error: no image named $image.img in $DIRIN"
		echo -e "${NC}"
	fi
}

repack_ext4_cmd() {
	$BIN/checkfsconfig $DIRROM/EXT4/$image $DIRROM/EXT4/config/$image/${image}_fs_config
	if [[ $image == system ]] || [[ $image == system_a ]] || [[ $image == system_b ]]; then
		sudo $BIN/make_ext4fs -J -T -1 -S "$DIRROM/EXT4/config/$image/${image}_file_contexts" -C "$DIRROM/EXT4/config/$image/${image}_fs_config" -l "$SIZE" -L "/" -a "/$image" "$DIROUT/$image.new.img" "$DIRROM/EXT4/$image"
	else
		sudo $BIN/make_ext4fs -J -T -1 -S "$DIRROM/EXT4/config/$image/${image}_file_contexts" -C "$DIRROM/EXT4/config/$image/${image}_fs_config" -l "$SIZE" -L "$image" -a "/$image" "$DIROUT/$image.new.img" "$DIRROM/EXT4/$image"
	fi
}

repack_erofs_as_ext4_cmd() {
	$BIN/checkfsconfig $erofsdir/$image $erofsdir/config/${image}_fs_config
	if [[ $image == system ]] || [[ $image == system_a ]] || [[ $image == system_b ]]; then
		sudo $BIN/make_ext4fs -J -T -1 -S "$erofsdir/config/${image}_file_contexts" -C "$erofsdir/config/${image}_fs_config" -l "$SIZE" -L "/" -a "/$image" "$DIROUT/$image.img" "$erofsdir/$image"
	else
		sudo $BIN/make_ext4fs -J -T -1 -S "$erofsdir/config/${image}_file_contexts" -C "$erofsdir/config/${image}_fs_config" -l "$SIZE" -L "$image" -a "/$image" "$DIROUT/$image.img" "$erofsdir/$image"
	fi
}

repack_erofs_cmd() {
	if [[ $legacy == true ]]; then
		other=" -E legacy-compress"
	else
		other=""
	fi
	
	$BIN/checkfsconfig $erofsdir/$image $erofsdir/config/${image}_fs_config
	$BIN/mkfs.erofs${other} -z${compression} -T $(date +%s) --mount-point="/$image" --fs-config-file="$erofsdir/config/${image}_fs_config" --file-contexts="$erofsdir/config/${image}_file_contexts" "$DIROUT/$image.erofs.img" "$erofsdir/$image/"
}

unpack_ext4_erofs_img() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to unpack"
	echo " "
	file_selector $DIRIN ".img"
	image=$FILE
	if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == ext4 ]]; then
	    unpack_ext4
	elif [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == erofs ]]; then
	    unpack_erofs
	else
	    echo ""
	    echo -e "${R}$image.img fs type is not ext4 or erofs!"
	    echo -e "${NC}"
	fi
}

repack_ext4_img_foldersize() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $DIRROM/EXT4
	image=$FOLDER
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo ""
		echo "- Repacking $image..."
		echo ""
		foldersize=$(sudo du -s -B1 $DIRROM/EXT4/$image | awk '{print $1}')
		SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		repack_ext4_cmd
		DIRIMG_RESIZE=$DIROUT/$image.new.img
		resize_img smallest
		echo ""
		echo "- Done!"
		echo ""
		if [[ $(ls -l $DIROUT/$image.new.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.new.img ${NC}"
		else
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_ext4_img_freespace() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $DIRROM/EXT4
	image=$FOLDER
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo " "
		echo "Input $image free space in mb (megabytes) :"
		read
		FREESPACE=$REPLY
		echo ""
		echo "- Repacking $image..."
		echo ""
		foldersize=$(sudo du -s -B1 $DIRROM/EXT4/$image | awk '{print $1}')
		SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		repack_ext4_cmd
		DIRIMG_RESIZE=$DIROUT/$image.new.img
		resize_img freespace
		echo ""
		echo "- Done!"
		echo ""
		if [[ $(ls -l $DIROUT/$image.new.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.new.img ${NC}"
		else
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_ext4_img_samesize() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $DIRROM/EXT4
	image=$FOLDER
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo ""
		echo "- Repacking $image..."
		echo ""
		SIZE=$(cat $DIRROM/EXT4/config/$image/${image}_size.txt)
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		repack_ext4_cmd
		echo ""
		echo "- Done!"
		echo ""
		if [[ $(ls -l $DIROUT/$image.new.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.new.img ${NC}"
		else
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_ext4_img_inputsize() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $DIRROM/EXT4
	image=$FOLDER
	if [[ -d $DIRROM/EXT4/$image ]]; then
		echo " "
		echo "Input partition size in bytes :"
		read
		SIZE=$REPLY
		if (( $SIZE < 1474560 )); then
		    SIZE=`sudo du -sk $DIRROM/EXT4/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		echo ""
		echo "- Repacking $image..."
		echo ""
		repack_ext4_cmd
		echo ""
		echo "- Done!"
		echo ""
		if [[ $(ls -l $DIROUT/$image.new.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.new.img ${NC}"
		else
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_erofs() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $erofsdir
	image=$FOLDER
	if [[ -d $erofsdir/$image ]]; then
		while true; do
		    read -p "Compiling erofs image for old kernel? (Y/N)" yn
		    case $yn in
			[Yy]* ) 
			legacy=true 
			break;;
			[Nn]* ) 
			legacy=false 
			break;;
			* ) echo "Please answer yes or no.";;
		    esac
		done
		
		while true; do
		   echo " "
		   echo "Choose compressor : "
		   echo " "
		   echo "1. lz4"
		   echo "2. lz4hc"
		   echo "3. lzma"
		   echo "4. deflate"
			    
		   read -p "" choose
		   case $choose in
			    
			1 ) 
			compressor=lz4
			break;;

			2 ) 
			compressor=lz4hc
			break;;
			
			3 )
			compressor=lzma
			break;;
			
			4 ) 
			compressor=deflate
			break;;

			* ) choose_compressor;;
		   esac
		done
		
		case $compressor in
		   "lz4" )
		      compression=lz4
		   ;;
		   
		   "lz4hc" )
		      echo ""
		      echo "Input erofs compression level (0-12, default is 9)"
		   ;;
		   
		   "lzma" )
		      echo ""
		      echo "Input erofs compression level (0-9,100-109. 0-9=normal, 100-109=extreme, default is 6)"
		   ;;
		   
		   "deflate" )
		      echo ""
		      echo "Input erofs compression level (0-9, default is 1)"
		   ;;
		esac
		
		if [[ $compressor != "lz4" ]]; then
		   echo "Leave it empty if you want the default compression"
		   read
		   erofscomplvl=$REPLY
		   if [[ $erofscomplvl == "" ]]; then
		      compression=${compressor}
		   else
		      compression=${compressor},${erofscomplvl}
		   fi
		fi
		
		echo " "
		echo "- Repacking $image..."
		echo ""
		repack_erofs_cmd
		echo ""
		echo "- Done!"
		echo ""
		if [[ $(ls -l $DIROUT/$image.erofs.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.erofs.img ${NC}"
		else
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

erofs_ext4_main() {
	erofs_ext4_normal() {
		clear
		banner
		echo " "
		echo "choose which image you wanted to convert to ext4"
		echo " "
		file_selector $DIRIN ".img"
		image=$FILE
		if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == erofs ]]; then
		   convert_erofs_ext4
		   rm -rf $erofsdir
		else
		   echo ""
		   echo -e "${R}$image.img fs type is $(blkid -o value -s TYPE $DIRIN/$image.img), aborting..."
		   echo -e "${NC}"
		fi
	}

	erofs_ext4_oplus() {
		clear
		for image in $oplus_partitions
		do
		  convert_erofs_ext4
		  rm -rf $erofsdir
		done
		if [[ $(blkid -o value -s TYPE $DIRIN/product.img) == erofs ]]; then
		    image=product
		    convert_erofs_ext4
		else
		    image=product
		    rebuild_ext4
		fi
		image=system_ext
		convert_erofs_ext4
		image=system
		convert_erofs_ext4
		rm -rf $erofsdir
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Convert erofs images to ext4"
	    echo "2. Convert OPlus my_xxx,system,system_ext partitions to ext4"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	erofs_ext4_normal
	restart_tool;;

		2 ) 
	erofs_ext4_oplus
	restart_tool;;

		x ) 
	start_tools;;

		* ) erofs_ext4_main;;
	    esac
	done
}

sparsechunk_converter() {
	clear
	banner
	echo ""
	echo "Input sparsechunk name:"
	echo 'example.. sparsechunk name is "super.img_sparsechunk.0-12", write "super.img_sparsechunk" here'
	read
	SPARSECHUNK=$REPLY
	
	if [[ -f $DIRIN/$SPARSECHUNK.0 ]]; then
	   echo ""
	   echo "Converting sparsechunk image into raw image"
	   simg2img $DIRIN/$SPARSECHUNK.* $DIROUT/super.img
	   rm -rf $DIRIN/$SPARSECHUNK.*
	   if [[ -f $DIROUT/super.img ]]; then
	       echo -e "${G}Done! Output : $DIROUT/super.img ${NC}"
	   else
	       echo -e "${R}Conversion Failed!"
	       echo -e "${NC}"
	   fi
	else
	  echo -e "${R}No sparsechunk with the name of $SPARSECHUNK in rom_input ${NC}"
	fi
}

merge_main() {
	merge_oplus() {
		clear
		if [[ -f $DIRIN/system_file_contexts ]] && [[ -f $DIRIN/system_fs_config ]]; then
		   merge() {
		     if [[ -f $DIRIN/${partition}_file_contexts ]] && [[ -f $DIRIN/${partition}_fs_config ]]; then
		     	echo ""
		     	echo "Merging $partition fs config & file contexts to system"
		     	echo ""
			gawk -i inplace 'NR>1' $DIRIN/${partition}_file_contexts

			python3 $OPLUSMERGE/$partition.py $DIRIN/${partition}_file_contexts
			python3 $OPLUSMERGE/$partition.py $DIRIN/${partition}_fs_config

			cat $DIRIN/${partition}_file_contexts >> $DIRIN/system_file_contexts
			cat $DIRIN/${partition}_fs_config >> $DIRIN/system_fs_config
		     else
		     	echo ""
		     	echo -e "${R}There's no $partition file contexts and/or fs config supplied ${NC}"
		     	echo ""
		     fi
		   }
		   
		   for partition in $oplus_partitions
		   do
		     merge
		   done

		   rm -rf $DIRIN/my_*
		   mv $DIRIN/system_file_contexts $DIROUT/
		   mv $DIRIN/system_fs_config $DIROUT/
			
		echo -e "${G}merged all fs context and config.. Output : $DIROUT ${NC}"

		else
			echo -e "${R}Error: put your system_file_contexts & system_fs_config to $DIRIN"
			echo -e "${NC}"
			
		fi
	}

	merge_non_dynamic() {
		clear
		if [[ -f $DIRIN/system_file_contexts ]] && [[ -f $DIRIN/system_fs_config ]] && [[ -f $DIRIN/system_ext_file_contexts ]] && [[ -f $DIRIN/system_ext_fs_config ]] && [[ -f $DIRIN/product_file_contexts ]] && [[ -f $DIRIN/product_fs_config ]]; then
			gawk -i inplace 'NR>1' $DIRIN/system_ext_file_contexts
			gawk -i inplace 'NR>1' $DIRIN/product_file_contexts

			python3 $MERGE/system_ext.py $DIRIN/system_ext_file_contexts
			python3 $MERGE/system_ext.py $DIRIN/system_ext_fs_config

			python3 $MERGE/product.py $DIRIN/product_file_contexts
			python3 $MERGE/product.py $DIRIN/product_fs_config


			cat $DIRIN/system_ext_file_contexts >> $DIRIN/system_file_contexts
			cat $DIRIN/system_ext_fs_config >> $DIRIN/system_fs_config

			cat $DIRIN/product_file_contexts >> $DIRIN/system_file_contexts
			cat $DIRIN/product_fs_config >> $DIRIN/system_fs_config


			rm -rf $DIRIN/product*
			rm -rf $DIRIN/system_ext*
			mv $DIRIN/system_file_contexts $DIROUT/
			mv $DIRIN/system_fs_config $DIROUT/

		else
			echo -e "${R}Error: you probably missed some important partitions fs conf and context..."
			echo -e "${NC}"
			
		fi
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Merge OPLUS my_* partition to system"
	    echo "2. Merge product and system_ext to system"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	merge_oplus
	restart_tool;;

		2 ) 
	merge_non_dynamic
	restart_tool;;

		x ) 
	start_tools;;

		* ) merge_main;;
	    esac
	done
}

mount_main() {
	mount_normal() {
		OPTIONS=loop
		clear
		if [[ -f $DIRROM/system_a.img ]] || [[ -f $DIRROM/vendor_a.img ]] || [[ -f $DIRROM/odm_a.img ]] || [[ -f $DIRROM/product_a.img ]] || [[ -f $DIRROM/system_ext_a.img ]]; then
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/${partition}_a.img $DIRROM/$partition >> /dev/null 2>&1
			done
		else
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/$partition.img $DIRROM/$partition >> /dev/null 2>&1
			done
		fi
		give_perm
	}

	mount_resize() {
		clear
		bash $BIN/resizeimg
		give_perm
	}

	mount_ro() {
		OPTIONS=ro,nosuid,nodev,relatime,uhelper=udisks2,loop
		clear
		if [[ -f $DIRROM/system_a.img ]] || [[ -f $DIRROM/vendor_a.img ]] || [[ -f $DIRROM/odm_a.img ]] || [[ -f $DIRROM/product_a.img ]] || [[ -f $DIRROM/system_ext_a.img ]]; then
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/${partition}_a.img $DIRROM/$partition >> /dev/null 2>&1
			done
		else
			for partition in $partitions
			do
			  sudo mount -t ext4 -o $OPTIONS $DIRROM/$partition.img $DIRROM/$partition >> /dev/null 2>&1
			done
		fi
		give_perm
	}
	
	while true; do
	    banner
	    echo " "
	    echo "1. Mount raw image and resize"
	    echo "2. Mount without resizing"
	    echo "3. Mount read only"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	mount_resize
	restart_tool;;

		2 ) 
	mount_normal
	restart_tool;;

		3 ) 
	mount_ro
	restart_tool;;

		x ) 
	start_tools;;

		* ) mount_main;;
	    esac
	done
}

payload() {
	clear
	if [ -f $DIRIN/payload.bin ]; then

		$BIN/payload --output=$DIROUT $DIRIN/payload.bin

		echo " "
		echo "cleaning..."

		rm -rf $DIRIN/payload.bin

		echo " "
		echo -e "Done! Output : $DIROUT ${NC}"

	else

		echo -e "${R}there's no payload.bin in $DIRIN"
		echo -e "${NC}"

	fi
}

custom_scripts() {
	clear
	banner
	echo ""
	echo "Choose which script to run :"
	ls -1 $DIRSCRIPTS/custom_scripts | awk '{print NR ".", $0}'
	echo "x. Back to main menu"
	read
	CHOOSE=$REPLY
	if [[ $CHOOSE == "x" ]]; then
	   start_tools
	elif [[ $CHOOSE == "" ]]; then
	   custom_scripts
	else
	   SCRIPT=$(ls -1 $DIRSCRIPTS/custom_scripts | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}')
	   exec $DIRSCRIPTS/custom_scripts/$SCRIPT
	fi
}

raw_sparse() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to convert to sparse img"
	echo " "
	file_selector $DIRIN ".img"
	imgname=$FILE

	if [ -f $DIRIN/$imgname.img ]; then

		echo " "
		echo "Converting raw image to sparse..."

		img2simg $DIRIN/$imgname.img $DIROUT/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img

		echo " "
		if [[ -f $DIROUT/$imgname.sparse.img ]]; then
		   echo -e "${G}Done! Output : $DIROUT/$imgname.sparse.img ${NC}"
		else
		   echo -e "${R}Conversion Failed!"
		   echo -e "${NC}"
		fi
	fi
}

raw_datbr() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to compress"
	echo " "
	file_selector $DIRIN ".img"
	imgname=$FILE

	if [ -f $DIRIN/$imgname.img ]; then
		echo " "
		echo "Input Brotli compression level (0-11) :"
		read
		COMPLVL=$REPLY

		echo " " 
		echo "converting image : $imgname to sparse"
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img

		echo " " 
		echo "converting image : $imgname to new.dat"
		python3 $BIN/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.sparse.img
		mv $DIRIN/system.new.dat $DIROUT/$imgname.new.dat
		mv $DIRIN/system.patch.dat $DIROUT/$imgname.patch.dat
		mv $DIRIN/system.transfer.list $DIROUT/$imgname.transfer.list
		rm -rf $DIRIN/system.*

		echo " " 
		echo "compressing image : $imgname using brotli..."

		brotli -q $COMPLVL $DIROUT/$imgname.new.dat
		echo " "
		echo "cleaning..."

		rm -rf $DIROUT/$imgname.new.dat
		echo " "
		if [[ -f $DIROUT/$imgname.new.dat.br ]]; then
		   echo -e "Done! Output : $DIROUT/$imgname.new.dat.br ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi
}

splits_main() {
	splits_compress() {
		clear
		dynamic_part_op_list=$DIROUT/dynamic_partitions_op_list
		SUPERSIZE=9124708352


		a_dp_op_list() {
			if [ -f $dynamic_part_op_list ]; then
				rm -f $dynamic_part_op_list;
			fi;
			
			touch $DIROUT/dynamic_partitions_op_list
			echo "# Remove all existing dynamic partitions and groups before applying full OTA" >> $dynamic_part_op_list
			echo "remove_all_groups" >>  $dynamic_part_op_list
			echo "# Add group qti_dynamic_partitions with maximum size $SUPERSIZE" >>  $dynamic_part_op_list
			echo "add_group qti_dynamic_partitions $SUPERSIZE" >>  $dynamic_part_op_list
			echo "# Add partition system to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add system qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition vendor to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add vendor qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition product to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add product qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition odm to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add odm qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "# Add partition system_ext to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			echo "add system_ext qti_dynamic_partitions" >>  $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Add partition mi_ext to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "add mi_ext qti_dynamic_partitions" >>  $dynamic_part_op_list
			fi
			echo "# Grow partition system from 0 to $SYSTEMSIZE" >>  $dynamic_part_op_list
			echo "resize system $SYSTEMSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition vendor from 0 to $VENDORSIZE" >>  $dynamic_part_op_list
			echo "resize vendor $VENDORSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition product from 0 to $PRODUCTSIZE" >>  $dynamic_part_op_list
			echo "resize product $PRODUCTSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition odm from 0 to $ODMSIZE" >>  $dynamic_part_op_list
			echo "resize odm $ODMSIZE" >>  $dynamic_part_op_list
			echo "# Grow partition system_ext from 0 to $SYSEXTSIZE" >>  $dynamic_part_op_list
			echo "resize system_ext $SYSEXTSIZE" >>  $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Grow partition mi_ext from 0 to $MIEXTSIZE" >>  $dynamic_part_op_list
			   echo "resize mi_ext $MIEXTSIZE" >>  $dynamic_part_op_list
			fi
		}

		ab_dp_op_list() {
			if [ -f $dynamic_part_op_list ]; then
				rm -f $dynamic_part_op_list;
			fi;
			
			touch $DIROUT/dynamic_partitions_op_list
			echo "# Remove all existing dynamic partitions and groups before applying full OTA" >> $dynamic_part_op_list
			echo "remove_all_groups" >> $dynamic_part_op_list
			echo "# Add group qti_dynamic_partitions_a with maximum size $SUPERSIZE" >> $dynamic_part_op_list
			echo "add_group qti_dynamic_partitions_a $SUPERSIZE" >> $dynamic_part_op_list
			echo "# Add group qti_dynamic_partitions_b with maximum size $SUPERSIZE" >> $dynamic_part_op_list
			echo "add_group qti_dynamic_partitions_b $SUPERSIZE" >> $dynamic_part_op_list
			echo "# Add partition system_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add system_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition system_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add system_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition system_ext_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add system_ext_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition system_ext_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add system_ext_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition product_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add product_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition product_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add product_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition vendor_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add vendor_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition vendor_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add vendor_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "# Add partition odm_a to group qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "add odm_a qti_dynamic_partitions_a" >> $dynamic_part_op_list
			echo "# Add partition odm_b to group qti_dynamic_partitions_b" >> $dynamic_part_op_list
			echo "add odm_b qti_dynamic_partitions_b" >> $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Add partition mi_ext_a to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "add mi_ext_a qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "# Add partition mi_ext_b to group qti_dynamic_partitions" >>  $dynamic_part_op_list
			   echo "add mi_ext_b qti_dynamic_partitions" >>  $dynamic_part_op_list
			fi
			echo "# Grow partition system_a from 0 to $SYSTEMSIZE" >> $dynamic_part_op_list
			echo "resize system_a $SYSTEMSIZE" >> $dynamic_part_op_list
			echo "# Grow partition system_ext_a from 0 to $SYSEXTSIZE" >> $dynamic_part_op_list
			echo "resize system_ext_a $SYSEXTSIZE" >> $dynamic_part_op_list
			echo "# Grow partition product_a from 0 to $PRODUCTSIZE" >> $dynamic_part_op_list
			echo "resize product_a $PRODUCTSIZE" >> $dynamic_part_op_list
			echo "# Grow partition vendor_a from 0 to $VENDORSIZE" >> $dynamic_part_op_list
			echo "resize vendor_a $VENDORSIZE" >> $dynamic_part_op_list
			echo "# Grow partition odm_a from 0 to $ODMSIZE" >> $dynamic_part_op_list
			echo "resize odm_a $ODMSIZE" >> $dynamic_part_op_list
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   echo "# Grow partition mi_ext_a from 0 to $MIEXTSIZE" >>  $dynamic_part_op_list
			   echo "resize mi_ext_a $MIEXTSIZE" >>  $dynamic_part_op_list
			fi
		}

		brotli_lvl() {
			echo " "
			echo "Input Brotli compression level (0-11) :"
			read
			COMPLVL=$REPLY
		}

		sparse() {
		    if [[ -f $DIRIN/$partition.img ]]; then
			echo ""
			echo "converting $partition into sparse"
			img2simg $DIRIN/$partition.img $DIRIN/$partition.sparse.img >> /dev/null 2>&1
			rm -rf $DIRIN/$partition.img
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.img supplied! skipping...${NC}"
		    fi
		}

		img2sdat() {
		    if [[ -f $DIRIN/$partition.sparse.img ]]; then
			echo " "
			echo "converting $partition into new.dat"
			python3 $BIN/img2sdat.py $DIRIN/$partition.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
			mv $DIRIN/system.new.dat $DIROUT/$partition.new.dat
			mv $DIRIN/system.patch.dat $DIROUT/$partition.patch.dat
			mv $DIRIN/system.transfer.list $DIROUT/$partition.transfer.list
			rm -rf $DIRIN/system.*
			rm -rf $DIRIN/$partition.*
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.sparse.img supplied! skipping...${NC}"
		    fi
		}

		datbr() {
		    if [[ -f $DIROUT/$partition.new.dat ]]; then
			echo " " 
			echo "compressing $partition using brotli..."
			brotli -q $COMPLVL $DIROUT/$partition.new.dat
			rm -rf $DIROUT/$partition.new.dat
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.new.dat supplied! skipping...${NC}"
		    fi
		}

		compress() {
			echo "========================================="

			for partition in $partitions
			do
			  sparse
			done
			if [[ -f $DIRIN/mi_ext.img ]]; then
			   partition=mi_ext
			   sparse
			fi

			echo " "
			echo "========================================="

			for partition in $partitions
			do
			  img2sdat
			done
			if [[ -f $DIRIN/mi_ext.sparse.img ]]; then
			   partition=mi_ext
			   img2sdat
			fi

			echo " "
			echo "========================================="

			for partition in $partitions
			do
			  datbr
			done
			if [[ -f $DIROUT/mi_ext.new.dat ]]; then
			   partition=mi_ext
			   datbr
			fi

			echo " "
			echo "========================================="
			echo " "
			echo -e "${G}Done! Output : $DIROUT ${NC}"

		}
		if [[ ! -f $DIRIN/system.img ]]; then
			touch $DIRIN/system.img
		fi
		if [[ ! -f $DIRIN/vendor.img ]]; then
			touch $DIRIN/vendor.img
		fi
		if [[ ! -f $DIRIN/odm.img ]]; then
			touch $DIRIN/odm.img
		fi
		if [[ ! -f $DIRIN/product.img ]]; then
			touch $DIRIN/product.img
		fi
		if [[ ! -f $DIRIN/system_ext.img ]]; then
			touch $DIRIN/system_ext.img
		fi
		if [[ ! -f $DIRIN/mi_ext.img ]]; then
			touch $DIRIN/mi_ext.img
		fi
		
		ODMSIZE=$(ls -nl $DIRIN/odm.img | awk '{print $5}')
		PRODUCTSIZE=$(ls -nl $DIRIN/product.img | awk '{print $5}')
		SYSTEMSIZE=$(ls -nl $DIRIN/system.img | awk '{print $5}')
		SYSEXTSIZE=$(ls -nl $DIRIN/system_ext.img | awk '{print $5}')
		VENDORSIZE=$(ls -nl $DIRIN/vendor.img | awk '{print $5}')
		if [[ -f $DIRIN/mi_ext.img ]]; then
		    MIEXTSIZE=$(ls -nl $DIRIN/mi_ext.img | awk '{print $5}')
		fi
			
		TOTALSIZE=$(( $ODMSIZE + $PRODUCTSIZE + $SYSTEMSIZE + $SYSEXTSIZE + $VENDORSIZE ))
		
		if [[ $SYSTEMSIZE == 0 ]]; then
			rm -rf $DIRIN/system.img
		fi
		if [[ $VENDORSIZE == 0 ]]; then
			rm -rf $DIRIN/vendor.img
		fi
		if [[ $ODMSIZE == 0 ]]; then
			rm -rf $DIRIN/odm.img
		fi
		if [[ $PRODUCTSIZE == 0 ]]; then
			rm -rf $DIRIN/product.img
		fi
		if [[ $SYSEXTSIZE == 0 ]]; then
			rm -rf $DIRIN/system_ext.img
		fi
		if [[ $MIEXTSIZE == 0 ]]; then
			rm -rf $DIRIN/mi_ext.img
		fi

		if (( $TOTALSIZE > $SUPERSIZE )); then
			echo "Total size of all partitions exceeds max super size, aborting..."
			echo "($TOTALSIZE/$SUPERSIZE)"
			echo ""
		else
			echo "Splits total size :"
			echo "($TOTALSIZE/$SUPERSIZE)"
			echo ""
			while true; do
			    echo "Compiling for A only device or Virtual A/B?"
			    echo "(1) A only"
			    echo "(2) Virtual A/B "
			    read -p "choose 1 or 2 : " choose
			    case $choose in
				[1]* ) 
			echo "Make sure to input your raw .img's to rom_input folder"
			echo " "
			echo "Compiling splits with A only format"
			echo " "

			brotli_lvl
			a_dp_op_list
			compress
			break;;

				[2]* ) 
			echo "Make sure to input your raw .img's to rom_input folder"
			echo " "
			echo "Compiling splits with Virtual A/B format"
			echo " "

			brotli_lvl
			ab_dp_op_list
			compress
			break;;
			
				* ) echo "Please answer 1 or 2.";;
			    esac
			done
		fi
	}

	splits_decompress() {
		clear
		datbr() {
		    if [[ -f $DIRIN/$partition.new.dat.br ]]; then
			echo " "
			echo "Decompressing $partition using brotli..."
			brotli -d $DIRIN/$partition.new.dat.br
			rm -rf $DIRIN/$partition.new.dat.br
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.new.dat.br supplied! skipping...${NC}"
		    fi
		}

		sdat2img() {
		    if [[ -f $DIRIN/$partition.new.dat ]] && [[ -f $DIRIN/$partition.transfer.list ]]; then
			echo " "
			echo "Converting $partition.new.dat to $partition.img (raw)"
			python3 $BIN/sdat2img.py $DIRIN/$partition.transfer.list $DIRIN/$partition.new.dat $DIROUT/$partition.img >> /dev/null 2>&1
			rm -rf $DIRIN/$partition.*
		    else
		    	echo " "
		    	echo -e "${R}there's no $partition.new.dat and/or $partition.transfer.list supplied! skipping...${NC}"
		    fi
		}

		echo "========================================="

		for partition in $partitions
		do
		  datbr
		done
		if [[ -f $DIRIN/mi_ext.new.dat.br ]]; then
		   partition=mi_ext
		   datbr
		fi

		echo " "
		echo "========================================="

		for partition in $partitions
		do
		  sdat2img
		done
		if [[ -f $DIRIN/mi_ext.new.dat ]]; then
		   partition=mi_ext
		   sdat2img
		fi

		echo " "
		echo "========================================="
		echo " "
		echo -e "${G}Done! Output : $DIROUT ${NC}"
	}

	while true; do
	    banner
	    echo " "
	    echo "1. Repack Splits (raw to dat.br)"
	    echo "2. Unpack Splits"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	splits_compress
	restart_tool;;

		2 ) 
	splits_decompress
	restart_tool;;

		x ) 
	start_tools;;

		* ) splits_main;;
	    esac
	done
}

sparse_raw() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to convert to raw img"
	echo " "
	file_selector $DIRIN ".img"
	imgname=$FILE
	
	if [ -f $DIRIN/$imgname.img ]; then
		echo " "
		echo "Converting sparse to raw image..."
		simg2img $DIRIN/$imgname.img $DIROUT/$imgname.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img
		echo " "
		if [[ $(ls -l $DIROUT/$imgname.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Done! Output : $DIROUT/$imgname.img ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi
}

super_u_raw() {
	clear
	banner
	echo " "
	echo "choose which super partition you wanted to extract"
	echo " "
	file_selector $DIRIN ".img"
	imgname=$FILE

	if [ -f $DIRIN/$imgname.img ]; then
		echo " "
		echo "Unpacking $imgname.img..."
		mkdir $DIRSUPER/config
		lpdump --slot=0 $DIRIN/$imgname.img > $DIRSUPER/config/super_config.txt
		lpunpack $DIRIN/$imgname.img $DIRROM/super
		rm -rf $DIRIN/$imgname.*

		echo " "
		echo -e "${G}Done! Output : $DIRROM/super ${NC}"
	fi
}
	
super_u_zstd() {
	clear
	banner
	echo " "
	echo "choose which super partition you wanted to extract"
	echo " "
	file_selector $DIRIN ""
	filename=$FILE
	
	if [ -f $DIRIN/$filename ]; then
		mv $DIRIN/$filename $DIRIN/$filename.zst
		
		echo " "
		echo "Decompressing $filename (zstd)"
		zstd -d $DIRIN/$filename.zst -o $DIRIN/super.img
		rm -rf $DIRIN/$filename.*

		echo " "
		echo "Unpacking super..."
		mkdir $DIRSUPER/config
		lpdump --slot=0 $DIRIN/super.img > $DIRSUPER/config/super_config.txt
		lpunpack $DIRIN/super.img $DIRROM/super
		rm -rf $DIRIN/super.img

		echo " "
		echo -e "${G}Done! Output : $DIRROM/super ${NC}"
	fi
}

super_u_datbr() {
	clear
	banner
	echo " "
	echo "choose which super partition you wanted to extract"
	echo " "
	file_selector $DIRIN ".new.dat.br"
	imgname=$FILE

	if [ -f $DIRIN/$imgname.new.dat.br ]; then

		echo "Decompressing brotli..."
		brotli -d $DIRIN/$imgname.new.dat.br
		rm -rf $DIRIN/$imgname.new.dat.br

		echo " "
		echo "Converting $imgname.new.dat to $imgname.img (raw)..."
		python3 $BIN/sdat2img.py $DIRIN/$imgname.transfer.list $DIRIN/$imgname.new.dat $DIROUT/$imgname.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.*

		echo " "
		echo "Unpacking $imgname.img..."
		mkdir $DIRSUPER/config
		lpdump --slot=0 $DIROUT/$imgname.img > $DIRSUPER/config/super_config.txt
		lpunpack $DIROUT/$imgname.img $DIRROM/super
		rm -rf $DIROUT/$imgname.*

		echo " "
		echo -e "${G}Done! Output : $DIRROM/super ${NC}"
	fi
}

super_r() {
	if [[ $(ls $DIRSUPER ) == "" ]]; then
	    banner
	    echo ""
	    echo -e "${R}No super extracted!${NC}"
	    restart_tool
	fi
	meta_size=$(cat $DIRSUPER/config/super_config.txt | awk '/Metadata max size:/ { print $4 }')
	meta_slot=$(cat $DIRSUPER/config/super_config.txt | awk '/Metadata slot count:/ { print $4 }')
	first_sector=$(cat $DIRSUPER/config/super_config.txt | awk '/First sector:/ { print ($3 * 512)}')
	group_table=$(cat $DIRSUPER/config/super_config.txt | grep -A10 "Group table:" | grep "Name:" | awk '{ print $2 }' | sed -n "2p")
	group_table2=$(cat $DIRSUPER/config/super_config.txt | grep -A10 "Group table:" | grep "Name:" | awk '{ print $2 }' | sed -n "3p")
	virtualAB=$(cat $DIRSUPER/config/super_config.txt | awk '/Header flags:/ { print $3 }')
	size_super=$(cat $DIRSUPER/config/super_config.txt | awk '/Size:/ { print $2 }')
	max_size_super=$(cat $DIRSUPER/config/super_config.txt | grep -A11 "Group table:" | grep "Maximum size:" | awk '{ print $3 }' | sed -n "2p")
	max_size_super2=$max_size_super
	
	configsize=$(du -s -b $DIRSUPER/config | awk '{print $1}')
	superdirsize=$(du -s -b $DIRSUPER | awk '{print $1}')
	TOTALSIZE=$(( $superdirsize - $configsize ))
	
	if [[ $virtualAB = "virtual_ab_device" ]]; then
	    virtualABOption="--virtual-ab "
	else
	    virtualABOption=""
	fi
	
	clear
	echo " "
	echo "Input Raw Super image name :"
	read
	imgname=$REPLY
	echo " "
	while true; do
	    read -p "Your super raw img name is : $imgname is that correct? (Y/N)" yn
	    case $yn in
		[Yy]* ) break;;
		[Nn]* ) restart_tool;;
		* ) echo "Please answer yes or no.";;
	    esac
	done
	
	while true; do
	   echo ""
	   echo "Compress image to :"
	   echo "1. raw"
	   echo "2. sparse"
	   echo "3. new.dat"
	   echo "4. dat.br"
	   echo "5. zstd"
	   read -p "" choose
	   case $choose in
		[1]* ) 
		COMPRESSION=raw
		break;;
		[2]* )
		COMPRESSION=sparse
		break;;
		[3]* )
		COMPRESSION=dat
		break;;
		[4]* )
		COMPRESSION=br
		echo " "
		echo "Input Brotli compression level (0-11) :"
		read
		COMPLVL=$REPLY
		break;;
		[5]* )
		COMPRESSION=zstd
		echo " "
		echo "Input zstd suffix (leave it empty if you want .zst) :"
		read
		ZSTDSUFFIX=.$REPLY
		if [[ $ZSTDSUFFIX == "." ]]; then
			ZSTDSUFFIX=.zst
		elif [[ $ZSTDSUFFIX == ". " ]]; then
			ZSTDSUFFIX=""
		fi
		echo " "
		echo "Input zstd compression lvl (1-19) :"
		read
		ZSTDLVL=$REPLY
		break;;
			
		* ) echo "Please answer with one of the above selections.";;
	   esac
	done

	if [[ $meta_slot == 1 ]] || [[ $meta_slot == 2 ]]; then
		echo " "
		echo "A only detected..."
		echo "Compiling super with A only format"
		echo " "

		part_list=$(cat $DIRSUPER/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }')
		
		if (( $TOTALSIZE > $max_size_super )); then
		echo "Total size of all partitions exceeds max super size, aborting..."
		echo "($TOTALSIZE/$max_size_super)"
		echo ""
		else
		echo "Super total size :"
		echo "($TOTALSIZE/$max_size_super)"
		echo ""
		echo "Compiling super : $imgname.img (raw)..."
		
		echo "#!/bin/bash" > $DIRSCRIPTS/build_super
		echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot --device=super:$size_super:$first_sector --group=$group_table:$max_size_super '\'" >> $DIRSCRIPTS/build_super

		for partition in $part_list; do
		   partition_size=$(ls -nl $DIRSUPER/$partition.img | awk '{print $5}')
		   echo "--partition=$partition:none:$partition_size:$group_table --image=$partition=$DIRSUPER/$partition.img '\'" >> $DIRSCRIPTS/build_super
		done

		echo "--output=$DIRIN/$imgname.img" >> $DIRSCRIPTS/build_super
		echo "exit" >> $DIRSCRIPTS/build_super
		
		sed -i "s/[']//g" $DIRSCRIPTS/build_super
		chmod 755 $DIRSCRIPTS/build_super
		$DIRSCRIPTS/build_super
		
		rm -rf $DIRSCRIPTS/build_super
		fi
	elif [[ $meta_slot == 3 ]]; then
		echo " "
		echo "Virtual A/B detected..."
		echo "Compiling super with Virtual A/B format"
		echo " "
		while true; do
		    echo "Choose which slot is active"
		    echo "1. A"
		    echo "2. B"
		    read -p "" choose
		    case $choose in
		[1]* ) 
			slot=_a
			emptyslot=_b
			break;;
		[2]* )
			slot=_b
			emptyslot=_a
			break;;
		* ) echo "Please answer 1 or 2.";;
		    esac
		done
		
		ab_part_list=$(cat $DIRSUPER/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }' | grep ${slot})
		ab_part_list_empty=$(cat $DIRSUPER/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }' | grep ${emptyslot})
		
		if (( $TOTALSIZE > $max_size_super )); then
		echo "Total size of all partitions exceeds max super size, aborting..."
		echo "($TOTALSIZE/$max_size_super)"
		echo ""
		else
		echo "Super total size :"
		echo "($TOTALSIZE/$max_size_super)"
		echo ""
		echo "Compiling super : $imgname.img (raw)..."
		
		echo "#!/bin/bash" > $DIRSCRIPTS/build_super
		if [[ $group_table2 != "" ]]; then
		    echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot ${virtualABOption}--device=super:$size_super:$first_sector --group=$group_table:$max_size_super --group=$group_table2:$max_size_super2 '\'" >> $DIRSCRIPTS/build_super
		else
		    echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot ${virtualABOption}--device=super:$size_super:$first_sector --group=$group_table:$max_size_super '\'" >> $DIRSCRIPTS/build_super
		fi
		
		for partition in $ab_part_list; do
		   partition_size=$(ls -nl $DIRSUPER/$partition.img | awk '{print $5}')
		   echo "--partition=$partition:none:$partition_size:$group_table --image=$partition=$DIRSUPER/$partition.img '\'" >> $DIRSCRIPTS/build_super
		done
		echo "--output=$DIRIN/$imgname.img" >> $DIRSCRIPTS/build_super
		
		if [[ $group_table2 != "" ]]; then
		    echo "touch $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super
		    for emptypartition in $ab_part_list_empty; do
		       echo "lpadd $DIRIN/$imgname.img $emptypartition $group_table2 $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super
		    done
		    echo "rm -rf $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super
		fi
		echo "exit" >> $DIRSCRIPTS/build_super
		
		sed -i "s/[']//g" $DIRSCRIPTS/build_super
		chmod 755 $DIRSCRIPTS/build_super
		$DIRSCRIPTS/build_super
		
		rm -rf $DIRSCRIPTS/build_super
		fi
	else
		echo -e "${R}Meta slot $meta_slot is not supported!"
		echo -e "${NC}"
	fi
	
	if [[ -f $DIRIN/$imgname.img ]]; then
		rm -rf $DIRSUPER/*
	fi
	
	case $COMPRESSION in
	   "raw" )
		echo " "
		mv $DIRIN/$imgname.img $DIROUT/$imgname.img
		if [[ -f $DIROUT/$imgname.img ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.img ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
		
	   "sparse" )
		echo " "
		echo "Converting raw $imgname.img to sparse..."
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img
		mv $DIRIN/$imgname.sparse.img $DIROUT/$imgname.sparse.img
		if [[ -f $DIROUT/$imgname.sparse.img ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.sparse.img ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
		
	   "dat" )
		echo " "
		echo "Converting raw $imgname.img to sparse..."
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img
		
		echo " "
		echo "Converting $imgname.img (sparse) to $imgname.new.dat..."
		python3 $BIN/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.*
		mv $DIRIN/system.new.dat $DIROUT/$imgname.new.dat
		mv $DIRIN/system.patch.dat $DIROUT/$imgname.patch.dat
		mv $DIRIN/system.transfer.list $DIROUT/$imgname.transfer.list
		rm -rf $DIRIN/$imgname.*
		if [[ -f $DIROUT/$imgname.new.dat ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.new.dat ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
	   
	   "br" )
		echo " "
		echo "Converting raw $imgname.img to sparse..."
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img
		
		echo " "
		echo "Converting $imgname.img (sparse) to $imgname.new.dat..."
		python3 $BIN/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIRIN/ -v 4 >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.*
		mv $DIRIN/system.new.dat $DIROUT/$imgname.new.dat
		mv $DIRIN/system.patch.dat $DIROUT/$imgname.patch.dat
		mv $DIRIN/system.transfer.list $DIROUT/$imgname.transfer.list
		rm -rf $DIRIN/$imgname.*
		
		echo " "
		echo "Compressing to $imgname.new.dat.br..."
		brotli -q $COMPLVL $DIROUT/$imgname.new.dat
		echo " "
		echo "cleaning..."
		echo " "
		rm -rf $DIROUT/$imgname.new.dat
		if [[ -f $DIROUT/$imgname.new.dat.br ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.new.dat.br ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
	   
	   "zstd" )
		echo " "
		echo "Compressing $imgname.img to ${imgname}$ZSTDSUFFIX (zstd)"
		zstd -${ZSTDLVL} $DIRIN/$imgname.img -o $DIROUT/${imgname}$ZSTDSUFFIX
		rm -rf $DIRIN/$imgname.img
		echo " "
		if [[ -f $DIROUT/${imgname}$ZSTDSUFFIX ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/${imgname}$ZSTDSUFFIX ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
	esac
}

super_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack Super (raw, sparse, .dat, .br, zstd)"
	    echo "2. Unpack Super (dat.br)"
	    echo "3. Unpack Super (zstd)"
	    echo "4. Unpack Super (raw)"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	super_r
	restart_tool;;

		2 ) 
	super_u_datbr
	restart_tool;;

		3 ) 
	super_u_zstd
	restart_tool;;
	
		4 ) 
	super_u_raw
	restart_tool;;

		x ) 
	start_tools;;

		* ) super_main;;
	    esac
	done
}

umount_main() {
	umount_resize_freespace() {
		clear
		resize_to_build(){
			if [ -f $DIRROM/${valset}_a.img ]; then
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
				
				vsizenow=$(ls -nl $DIRROM/${valset}_a.img | awk '{print $5}')
				sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
				sudo resize2fs $DIRROM/${valset}_a.img $sizeimg
				sudo e2fsck -yf $DIRROM/${valset}_a.img
			else
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
				
				vsizenow=$(ls -nl $DIRROM/${valset}.img | awk '{print $5}')
				sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
				sudo resize2fs $DIRROM/${valset}.img $sizeimg > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
			fi;
		}

		echo " "
		echo "Input partition that you want to unmount :"
		read
		PARTITION=$REPLY

		if [[ $PARTITION == "system" ]] || [[ $PARTITION == "system_ext" ]] || [[ $PARTITION == "product" ]] || [[ $PARTITION == "odm" ]] || [[ $PARTITION == "vendor" ]]; then

			echo " "
			echo "Input partiton free space in mb (megabytes) :"
			read
			FREESPACE=$REPLY
			
			echo " "
			echo "Unmounting $PARTITION..."
			echo " "
			restore_perm > /dev/null 2>&1
			sudo umount $DIRROM/$PARTITION >> /dev/null 2>&1

			echo "Resizing $PARTITION..."
			echo " "
			# Resize image to minimum
			valset=$PARTITION
			resize_to_build
		else
			echo -e "${R}there's no partition named : $PARTITION"
			echo -e "${NC}"
		fi
	}
	umount_resize() {
		clear
		resize_to_build(){
			if [ -f $DIRROM/${valset}_a.img ]; then
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}_a.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}_a.img > /dev/null 2>&1
			else
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
				sudo resize2fs -M $DIRROM/${valset}.img > /dev/null 2>&1
				sudo e2fsck -yf $DIRROM/${valset}.img > /dev/null 2>&1
			fi;
		}
		echo " "
		echo "Unmounting partitions..."
		echo " "
		restore_perm > /dev/null 2>&1
		for partition in $partitions
		do
	 	 sudo umount $DIRROM/$partition >> /dev/null 2>&1
		done

		echo "Resizing partitions..."
		echo " "
		# Resize image to minimum
		for valset in $partitions
		do
		  resize_to_build
		done
	}
	umount_normal() {
		clear
		echo " "
		echo "Unmounting partitions..."
		echo " "
		restore_perm > /dev/null 2>&1
		for partition in $partitions
		do
	 	 sudo umount $DIRROM/$partition >> /dev/null 2>&1
		done
	}
	
	while true; do
	    banner
	    echo " "
	    echo "1. Umount raw image and resize to smallest size"
	    echo "2. Umount raw image and resize with free space "
	    echo "3. Umount without resizing"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	umount_resize
	restart_tool;;

		2 ) 
	umount_resize_freespace
	restart_tool;;

		3 ) 
	umount_normal
	restart_tool;;

		x ) 
	start_tools;;

		* ) umount_main;;
	    esac
	done
}

zip_main() {
	oplus_zip() {
		ZIPNAME=$DIRTOOLS/oplus.zip
		clear
		cd $DIROUT
		zip $ZIPNAME my_* system.img vendor.img odm.img product.img system_ext.img
		cd $DIRTOOLS
	}
	splits_zip() {
		ZIPNAME=$DIRTOOLS/split-partition.zip
		clear
		cd $DIROUT
		zip $ZIPNAME dynamic_partitions_op_list system.* vendor.* odm.* product.* system_ext.*
		cd $DIRTOOLS
	}
	
	while true; do
	    banner
	    echo " "
	    echo "*this will zip files in rom_output folder*"
	    echo " "
	    echo "1. Zip Oplus images"
	    echo "2. Zip Compressed Split partitions"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	oplus_zip
	restart_tool;;

		2 ) 
	splits_zip
	restart_tool;;

		x ) 
	start_tools;;

		* ) zip_main;;
	    esac
	done
}

install_req() {
	while true; do
	    banner
	    echo ""
	    echo "Choose your linux distribution base"
	    echo "1. Arch"
	    echo "2. Redhat"
	    echo "3. Ubuntu"
	    echo "x. Back to main menu"
	    read -p "" choose
	    case $choose in
		1 ) 
		sudo pacman -Sy --noconfirm android-tools gawk erofs-utils brotli cpio
		restart_tool;;
		
		2 )
		sudo dnf install android-tools erofs-utils gawk cpio
		restart_tool;;
		
		3 )
		sudo apt install brotli android-sdk-libsparse-utils gawk wget android-tools cpio
		restart_tool;;
		
		x )
		start_tools;;
		
		* ) 
		install_req;;
	    esac
	done
}


repack_ext4_erofs() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack EXT4 image with old image size"
	    echo "2. Repack EXT4 image with folder size"
	    echo "3. Repack EXT4 image with free space"
	    echo "4. Repack EXT4 image and manually input size"
	    echo "5. Repack EROFS image"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	repack_ext4_img_samesize
	restart_tool;;

		2 ) 
	repack_ext4_img_foldersize
	restart_tool;;
	
		3 )
	repack_ext4_img_freespace
	restart_tool;;
	
		4 ) 
	repack_ext4_img_inputsize
	restart_tool;;
	
		5 )
	repack_erofs
	restart_tool;;
	
		x ) 
	start_tools;;

		* ) repack_ext4;;
	    esac
	done
}

unpack_repack_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack EXT4/EROFS image"
	    echo "2. Unpack EXT4/EROFS image"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	repack_ext4_erofs
	restart_tool;;

		2 ) 
	unpack_ext4_erofs_img
	restart_tool;;
	
		x ) 
	start_tools;;

		* ) unpack_repack_main;;
	    esac
	done
}

cd_cv_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Convert dat.br to raw img"
	    echo "2. Convert raw .img to dat.br"
	    echo "3. Convert raw to sparse"
	    echo "4. Convert sparse to raw"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	datbr_raw
	restart_tool;;

		2 ) 
	raw_datbr
	restart_tool;;

		3 ) 
	raw_sparse
	restart_tool;;
	
		4 )
	sparse_raw
	restart_tool;;

		x ) 
	start_tools;;

		* ) cd_cv_main;;
	    esac
	done
}

zstd_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Compress zstd"
	    echo "2. Decompress zstd"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	compress_zstd
	restart_tool;;

		2 ) 
	decompress_zstd
	restart_tool;;

		x ) 
	start_tools;;

		* ) zstd_main;;
	    esac
	done
}

start_tools() {
	setup
	while true; do
	    banner
	    echo " "
	    echo "1. Super partition tools"
	    echo "2. Split partition tools (system,vendor,odm,system_ext,product)"
	    echo "3. Convert or compress images"
	    echo "4. Unpack or repack images"
	    echo "5. Convert erofs to ext4"
	    echo "6. Rebuild EXT4 Images (removes avb)"
	    echo "7. Mount raw .img"
	    echo "8. Unmount images"
	    echo "9. Unpack payload.bin"
	    echo "10. Custom Scripts"
	    echo "11. Merge fs context and config to system"
	    echo "12. Auto ZIP"
	    echo "13. Zstd Tools"
	    echo "14. Sparsechunk converter"
	    echo "c. Clean up folders"
	    echo "0. Install proprietary packages"
	    echo "x. Exit tool"
	    
	    read -p "" choose
	    case $choose in
	    
		0 ) 
	install_req
	restart_tool;;

		1 ) 
	super_main
	restart_tool;;

		2 ) 
	splits_main
	restart_tool;;

		3 ) 
	cd_cv_main
	restart_tool;;

		4 ) 
	unpack_repack_main
	restart_tool;;

		5 ) 
	erofs_ext4_main
	restart_tool;;

		6 ) 
	rebuild_ext4_single
	restart_tool;;

		7 ) 
	mount_main
	restart_tool;;

		8 ) 
	umount_main
	restart_tool;;

		9 ) 
	payload
	restart_tool;;

		10 ) 
	custom_scripts
	restart_tool;;

		11 ) 
	merge_main
	restart_tool;;

		12 ) 
	zip_main
	restart_tool;;
	
		13 ) 
	zstd_main
	restart_tool;;
	
		14 )
	sparsechunk_converter
	restart_tool;;

		c ) 
	clean
	restart_tool;;

		x )  
	clear	
	exit;;
		* ) start_tools;;
	    esac
	done
}
