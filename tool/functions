#!/bin/bash
DIRTOOLS=$PWD
DIRSCRIPTS=$DIRTOOLS/tool
BIN=$DIRSCRIPTS/bin
PYSCRIPTS=$BIN/py
ABIEBIN=$BIN/booteditor
DIRIN=$DIRTOOLS/input
DIROUT=$DIRTOOLS/output
WORKDIR=$DIRTOOLS/ROM_WORKDIR
superdir=$WORKDIR/super
ext4dir=$WORKDIR/EXT4
erofsdir=$WORKDIR/erofs
f2fsdir=$WORKDIR/F2FS
u_bootdir=$WORKDIR/boot
partitions="system vendor odm product system_ext"
oplus_partitions="my_bigball my_carrier my_company my_engineering my_heytap my_manifest my_preload my_product my_region my_stock"
G='\033[1;32m'
R='\033[1;31m'
NC='\033[0m'
LC='\033[1;36m'

restart_tool() {
	echo " "
	while true; do
	   echo "start tools again? (y/n)"
	   read -p "" yn
	   case $yn in
		[Yy]* ) start_tools;;
		[Nn]* ) 
		clear
		exit;;   
		* ) echo "please choose yes or no";;
	    esac
	done
}

banner() {
	clear
	echo -e "${LC}+-------------------------+"
	echo -e "${LC}|   ROM TOOLS FOR LINUX   |"
	echo -e "${LC}|        by  Danda        |"
	echo -e "${LC}+-------------------------+${NC}"
}

booteditor_banner() {
	clear
	echo -e "${LC}+-------------------------+"
	echo -e "${LC}|Android Boot Image Editor|"
	echo -e "${LC}|         by cfig         |"
	echo -e "${LC}+-------------------------+${NC}"
}

getvalue() { grep "^$1=" "$2" 2>/dev/null | tail -n1 | cut -d= -f2-; }

give_perm() {
	local partiton=$1
	sudo chown -R $USER:$USER $WORKDIR/$partition >> /dev/null 2>&1
}

restore_perm() {
	local partition=$1
	if [[ $(echo $partition | grep "vendor") != "" ]]; then
		sudo chown -R 0:0 $WORKDIR/$partition/
		sudo chown -R 0:2000 $WORKDIR/$partition/bin
		sudo chown 0:2000 $(sudo find $WORKDIR/$partition -type d)
	elif [[ $(echo $partition | grep "system") != "" ]]; then
		sudo chown -R 0:0 $WORKDIR/$partition
		sudo chown -R 0:2000 $WORKDIR/$partition/system/bin
	else
		sudo chown -R 0:0 $WORKDIR/$partition
		sudo chown -R 0:2000 $WORKDIR/$partition/bin
	fi
}

setup() {
	clear
	if [[ ! -d $WORKDIR ]] && [[ ! -d $DIRIN ]] && [[ ! -d $DIROUT ]]; then
		mkdir -p $DIRIN \
		         $DIROUT \
		         $WORKDIR
		if [[ ! -f /bin/romtools ]]; then
		    echo "#!/bin/bash" > $DIRSCRIPTS/romtools
		    echo "cd $DIRTOOLS" >> $DIRSCRIPTS/romtools
		    echo "$DIRTOOLS/start" >> $DIRSCRIPTS/romtools
		    sudo mv $DIRSCRIPTS/romtools /bin/romtools
		    sudo chmod 755 /bin/romtools
		fi
	fi
}

clean() {
	clear
	echo "cleaning..."

	rm -rf $DIRIN \
	       $DIROUT \
	       $WORKDIR \
		   $ABIEBIN/uiderrors \
		   $ABIEBIN/*.img*
		   
	sudo find $DIRSCRIPTS/ -name "__pycache__" -type d -exec rm -rf {} +

	echo -e "${G}Done!${NC}"
}

file_selector() {
	local selected_dir=$1
	local file_extension=$2
	local message=$3
	if ls -1 $selected_dir/*$file_extension > /dev/null 2>&1 ; then
	   ls -1 $selected_dir/*$file_extension | sed 's:.*/::' | awk '{print NR ".", $0}'
	   local nofilesfound=0
	else
	   if [[ $file_extension == "" ]]; then
	      echo -e "${R}No file(s) found in $selected_dir ${NC}"
	      echo ""
	   else
	      echo -e "${R}No file(s) found in $selected_dir with $file_extension file extension ${NC}"
	      echo ""
	   fi
	   local nofilesfound=1
	fi
	if [[ $message != "" ]] && [[ $nofilesfound == 0 ]]; then
	   echo "0. $message"
	fi
	echo "x. Back to main menu"
	read
	local CHOOSE=$REPLY
	if [[ $CHOOSE == "0" ]]; then
	   clear
	   FILE=$(ls -1 $selected_dir/*$file_extension | sed 's:.*/::' | sed "s/${file_extension}$//")
	elif [[ $CHOOSE == "x" ]]; then
	   start_tools
	elif [[ $CHOOSE == "" ]]; then
	   clear
	   banner
	   echo ""
	   file_selector $selected_dir $file_extension $message
	else
	   if [[ $(ls -1 $selected_dir | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)") == "" ]]; then
	      clear
	      banner
	      echo ""
	      file_selector $selected_dir $file_extension $message
	   fi
	   if [[ $file_extension == "" ]]; then
	      FILE=$(ls -1 $selected_dir | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}')
	      clear
	      echo "Selected: $FILE"
	   else
	      local file1=$(ls -1 $selected_dir/*$file_extension | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}' | sed "s/$file_extension//")
	      local file2=${file1%/}
	      local file3=${file2##*/}
	      FILE=$file3
	      clear
	      echo "Selected: ${FILE}${file_extension}"
	   fi
	fi
}

extracted_partition_selector() {
	local selected_dir=$1
	local message=$2
	if ls -1 $selected_dir > /dev/null 2>&1 ; then
	   ls -1 $selected_dir | grep -v "config" | awk '{print NR ".", $0}'
	   local nofoldersfound=0
	else
	   echo -e "${R}No extracted partition(s) found! ${NC}"
	   echo ""
	   local nofoldersfound=1
	fi
	if [[ $message != "" ]] && [[ $nofoldersfound == 0 ]]; then
	   echo "0. $message"
	fi
	echo "x. Back to main menu"
	read
	local CHOOSE=$REPLY
	if [[ $CHOOSE == "0" ]]; then
	   clear
	   FOLDER=$(ls -1 $selected_dir | grep -v "config")
	elif [[ $CHOOSE == "x" ]]; then
	   start_tools
	elif [[ $CHOOSE == "" ]]; then
	   clear
	   banner
	   echo ""
	   extracted_partition_selector $selected_dir $message
	else
	   FOLDER=$(ls -1 $selected_dir | grep -v "config" | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}')
	   if [[ $FOLDER != "" ]]; then
	      clear
	      echo "Selected: $FOLDER"
	   else
	      clear
	      banner
	      echo ""
	      extracted_partition_selector $selected_dir $message
	   fi
	fi
}

resize_img(){
	local DIRIMG_RESIZE=$1
	if [[ $2 == "smallest" ]]; then
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
		sudo resize2fs -M $DIRIMG_RESIZE > /dev/null 2>&1
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
	elif [[ $2 == "freespace" ]]; then
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
		sudo resize2fs -M $DIRIMG_RESIZE > /dev/null 2>&1
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
		local vsizenow=$(ls -nl $DIRIMG_RESIZE | awk '{print $5}')
		local sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
		sudo resize2fs $DIRIMG_RESIZE $sizeimg > /dev/null 2>&1
		sudo e2fsck -yf $DIRIMG_RESIZE > /dev/null 2>&1
	fi
}

patch_merge_fsconf_contexts() {
	local image=$1
	sed -i "s#${image}/#system/${image}/#g" $2
	sed -i "s#/${image}/#/system/${image}/#g" $3
}

repack_bootimg() {
	clear
	booteditor_banner
	echo " "
	echo "choose which image you wanted to repack"
	echo " "
	extracted_partition_selector $u_bootdir "Repack all images shown"
	for imgname in $FOLDER; do
		local img=$imgname.img
		if [[ $img != "vbmeta.img" ]] && [[ -f $DIRIN/vbmeta.img ]]; then
			mv $DIRIN/vbmeta.img $ABIEBIN/
		elif [[ $img != "vbmeta.img" ]] && [[ -f $u_bootdir/vbmeta/vbmeta.img ]]; then
			mv $u_bootdir/vbmeta/vbmeta.img $ABIEBIN/
		fi
		mv $u_bootdir/$imgname/$img $ABIEBIN/
		mv $u_bootdir/$imgname $ABIEBIN/build
		cd $ABIEBIN
		java -jar $ABIEBIN/bbootimg/bbootimg.jar pack
		cd $DIRTOOLS
		mv $ABIEBIN/$img $ABIEBIN/build
		mv $ABIEBIN/build $u_bootdir/$imgname
		if [[ -f $ABIEBIN/$img.signed ]]; then
			mv $ABIEBIN/$img.signed $DIROUT/$imgname.signed.img
			echo ""
			echo -e "${G}Output: $DIROUT/$imgname.signed.img${NC}"
		elif [[ -f $ABIEBIN/$img.clear ]]; then
			mv $ABIEBIN/$img.clear $DIROUT/$imgname.unsigned.img
			echo ""
			echo -e "${G}Output: $DIROUT/$imgname.unsigned.img${NC}"
		else
			echo ""
			echo -e "${R}Repacking failed!${NC}"
		fi
		if [[ $img != "vbmeta.img" ]] && [[ -f $ABIEBIN/vbmeta.img ]] && [[ -d $u_bootdir/vbmeta ]]; then
			mv $ABIEBIN/vbmeta.img $u_bootdir/vbmeta/
		elif [[ $img != "vbmeta.img" ]] && [[ -f $ABIEBIN/vbmeta.img ]] && [[ ! -d $u_bootdir/vbmeta ]]; then
			mv $ABIEBIN/vbmeta.img $DIRIN/
		fi
	done
}

unpack_bootimg() {
	clear
	booteditor_banner
	echo " "
	echo "choose which image you wanted to unpack"
	echo " "
	file_selector $DIRIN ".img"
	local img=$FILE.img
	local extracted_folder=$FILE
	mkdir -p $u_bootdir
	if [[ -d $u_bootdir/$extracted_folder ]]; then
		rm -rf $u_bootdir/$extracted_folder
	fi
	if [[ $img != "vbmeta.img" ]] && [[ -f $DIRIN/vbmeta.img ]]; then
	   mv $DIRIN/vbmeta.img $ABIEBIN/
	fi
	cd $ABIEBIN/
	mv $DIRIN/$img $ABIEBIN/
	java -jar $ABIEBIN/bbootimg/bbootimg.jar unpack
	mv $ABIEBIN/$img $ABIEBIN/build/
	mv $ABIEBIN/build $u_bootdir/$extracted_folder
	if [[ $img != "vbmeta.img" ]] && [[ -f $ABIEBIN/vbmeta.img ]]; then
	   mv $ABIEBIN/vbmeta.img $DIRIN/
	fi
	cd $DIRTOOLS
	echo ""
	echo -e "Output: $u_bootdir/$extracted_folder"
}

convert_erofs_ext4(){
	echo " "
	echo "Starting conversion..."
	echo ""
	echo "- Unpacking $image image (erofs)"
	$BIN/erofs.unpack -i $DIRIN/$image.img -o $erofsdir -x > /dev/null 2>&1
	        
	echo "- Rebuilding $image as ext4 image..."
	local foldersize=$(du -s -B1 $erofsdir/$image | awk '{print $1}')
	local SIZE=$(($foldersize + $foldersize * 1/10))
	if (( $SIZE < 1474560 )); then
	    local SIZE=`sudo du -sk $erofsdir/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
	fi
	repack_erofs_as_ext4_cmd $image $SIZE > /dev/null 2>&1
	resize_img $DIROUT/$image.img smallest
	echo ""
	if [[ -f $DIROUT/$image.img ]] && [[ $(ls -l $DIROUT/$image.img | awk '{print $5}') != "0" ]]; then
	   rm -rf $DIRIN/$image.img
	   echo -e "${G}Conversion done..."
	   echo -e "Output : $DIROUT/$image.img ${NC}"
	else
	   echo -e "${R}Conversion Failed!"
	   echo -e "${NC}"
	fi
}
		
rebuild_ext4(){
	echo " "
	echo "Starting rebuilding..."
	echo ""
	echo "- Extracting $partition"
	mkdir -p $WORKDIR/rebuildimg
	sudo $PYSCRIPTS/imgextractor.py $DIRIN/$partition.img $WORKDIR/rebuildimg > /dev/null 2>&1
	local foldersize=$(sudo du -s -B1 $WORKDIR/rebuildimg/$partition | awk '{print $1}')
	local SIZE=$(($foldersize + $foldersize * 1/10))
	if (( $SIZE < 1474560 )); then
		local SIZE=`sudo du -sk $WORKDIR/rebuildimg/$partition | awk '{$1*=1024;$1=int($1*8);printf $1}'`
	fi
	echo "- Rebuilding $partition..."
	if [[ $partition == system ]] || [[ $partition == system_a ]] || [[ $partition == system_b ]]; then
		sudo $BIN/make_ext4fs -J -T -1 \
		   -S "$WORKDIR/rebuildimg/config/$partition/${partition}_file_contexts" \
		   -C "$WORKDIR/rebuildimg/config/$partition/${partition}_fs_config" \
		   -l "$SIZE" \
		   -L "/" \
		   -a "/$partition" \
		   "$DIROUT/$partition.img" "$WORKDIR/rebuildimg/$partition" > /dev/null 2>&1
	else
		sudo $BIN/make_ext4fs -J -T -1 \
		   -S "$WORKDIR/rebuildimg/config/$partition/${partition}_file_contexts" \
		   -C "$WORKDIR/rebuildimg/config/$partition/${partition}_fs_config" \
		   -l "$SIZE" \
		   -L "$partition" \
		   -a "/$partition" \
		   "$DIROUT/$partition.img" "$WORKDIR/rebuildimg/$partition" > /dev/null 2>&1
	fi
	resize_img $DIROUT/$partition.img smallest
	sudo rm -rf $WORKDIR/rebuildimg
	echo ""
	if [[ -f $DIROUT/$partition.img ]] && [[ $(ls -l $DIROUT/$partition.img | awk '{print $5}') != "0" ]]; then
		rm -rf $DIRIN/$partition.img
		echo -e "${G}Rebuild done..."
		echo -e "Output : $DIROUT/$partition.img ${NC}"
	else
		echo -e "${R}Rebuild Failed!"
		echo -e "${NC}"
	fi
}

rebuild_ext4_single() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to rebuild"
	echo " "
	file_selector $DIRIN ".img" "Rebuild all ext4 image shown above"
	for partition in $FILE; do
		if [[ $(blkid -o value -s TYPE $DIRIN/$partition.img) == ext4 ]]; then
		  rebuild_ext4
		else
		   echo ""
		   echo -e "${R}$partition.img fs type is $(blkid -o value -s TYPE $DIRIN/$partition.img), aborting..."
		   echo -e "${NC}"
		fi
	done
}

datbr_raw() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to extract"
	echo " "
	file_selector $DIRIN ".new.dat.br"
	local imgname=$FILE

	if [ -f $DIRIN/$imgname.new.dat.br ]; then
		echo "Unpacking..."
		echo " "
		brotli -d $DIRIN/$imgname.new.dat.br

		rm -rf $DIRIN/$imgname.new.dat.br

		python3 $PYSCRIPTS/sdat2img.py $DIRIN/$imgname.transfer.list $DIRIN/$imgname.new.dat $DIROUT/$imgname.img  >> /dev/null 2>&1
		echo " "
		echo "Cleaning input folder..."

		echo " "
		if [[ -f $DIROUT/$imgname.img ]] && [[ $(ls -l $DIROUT/$imgname.img | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIRIN/$imgname.*
		   echo -e "${G}Done! Output : $DIROUT/$imgname.img ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi
}

compress_zstd() {
	clear
	banner
	echo " "
	echo "choose which file you wanted to compress"
	echo " "
	file_selector $DIRIN ""
	local filename=$FILE
	
	if [ -f $DIRIN/$filename ]; then
		echo " "
		echo "Input zstd suffix (leave it empty if you want .zst) :"
		read
		local ZSTDSUFFIX=.$REPLY
		if [[ $ZSTDSUFFIX == "." ]]; then
			local ZSTDSUFFIX=.zst
		elif [[ $ZSTDSUFFIX == ". " ]]; then
			local ZSTDSUFFIX=""
		fi
		
		echo " "
		echo "Input zstd compression lvl (1-19) :"
		read
		local ZSTDLVL=$REPLY
		
		echo " "
		echo "Compressing $filename to ${filename}$ZSTDSUFFIX (zstd)"
		zstd -${ZSTDLVL} -T$(nproc --all) $DIRIN/$filename -o $DIROUT/${filename}$ZSTDSUFFIX
		rm -rf $DIRIN/$filename
		echo " "
		if [[ -f $DIROUT/${filename}$ZSTDSUFFIX ]] && [[ $(ls -l $DIROUT/${filename}$ZSTDSUFFIX | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Done! Output : $DIROUT/${filename}$ZSTDSUFFIX ${NC}"
		else
		   echo -e "${R}Compression Failed!"
		   echo -e "${NC}"
		fi
	fi	
}

decompress_zstd() {
	clear
	banner
	echo " "
	echo "choose which file you wanted to decompress"
	echo " "
	file_selector $DIRIN ""
	local filename=$FILE
	
	if [[ $(file $DIRIN/$filename | grep "Zstandard") != "" ]]; then
		mv $DIRIN/$filename $DIRIN/$filename.zst
		
		echo " "
		echo "Input $filename output name :"
		read
		local outputname=$REPLY
		
		echo " "
		echo "Decompressing $filename (zstd)"
		zstd -d $DIRIN/$filename.zst -o $DIROUT/$outputname
		rm -rf $DIRIN/$filename.*
		echo " "
		if [[ -f $DIROUT/$outputname ]] && [[ $(ls -l $DIROUT/$outputname | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}Done! Output : $DIROUT/$outputname ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	else
		echo " "
		echo -e "${R}File type is not Zstandard! aborting...${NC}"
	fi	
}

unpack_ext4() {
	mkdir -p $ext4dir
	if [[ -d $ext4dir/$image ]]; then
		echo "Folder named $image in $ext4dir exists, it will be deleted!"
		echo "Move it somewhere first if its important"
		echo "Press ENTER to confirm."
		read
		rm -rf $ext4dir/$image
		rm -rf $ext4dir/config/$image
	fi
	echo ""
	sudo $PYSCRIPTS/imgextractor.py $DIRIN/$image.img $WORKDIR/EXT4
	sudo chown -R $USER:$USER $WORKDIR/EXT4
	echo ""
	echo -e "${G}Output : $ext4dir/$image ${NC}"
	rm -rf $DIRIN/$image.img
}

unpack_erofs() {
	mkdir -p $erofsdir
	if [[ -d $erofsdir/$image ]]; then
		echo "Folder named $image in $erofsdir exists, it will be deleted!"
		echo "Move it somewhere first if its important"
		echo "Press ENTER to confirm."
		read
		rm -rf $erofsdir/$image
		rm -rf $erofsdir/config/$image_*
	fi
	echo ""
	$BIN/erofs.unpack -i $DIRIN/$image.img -o $erofsdir -x
	echo ""
	echo -e "${G}Output : $erofsdir/$image ${NC}"
	rm -rf $DIRIN/$image.img
}

unpack_f2fs(){
	mkdir -p $f2fsdir/config/tmp
	if [[ -d $f2fsdir/$image ]]; then
		echo "Folder named $image in $f2fsdir exists, it will be deleted!"
		echo "Move it somewhere first if its important"
		echo "Press ENTER to confirm."
		read
		rm -rf $f2fsdir/$image
		rm -rf $f2fsdir/config/$image_*
	fi
	echo ""
	echo "Unpacking $image.img (F2FS)..."
	$BIN/extract.f2fs -o $f2fsdir $DIRIN/$image.img >> /dev/null 2>&1
	echo ""
	if [[ -d $f2fsdir/$image ]]; then
		echo -e "${G}Output : $f2fsdir/$image ${NC}"
		mv $DIRIN/$image.img $f2fsdir/config/tmp/$image.img
	else
		echo -e "${R}Unpacking failed!${NC}"
	fi
}

repack_ext4_cmd() {
	local partition=$1
	local SIZE=$2
	$BIN/checkfsconfig $ext4dir/$partition $ext4dir/config/$partition/${partition}_fs_config
	if [[ $partition == system ]] || [[ $partition == system_a ]] || [[ $partition == system_b ]]; then
		sudo $BIN/make_ext4fs -J -T -1 \
		   -S "$ext4dir/config/$partition/${partition}_file_contexts" \
		   -C "$ext4dir/config/$partition/${partition}_fs_config" \
		   -l "$SIZE" \
		   -L "/" \
		   -a "/$partition" \
		   "$DIROUT/$partition.ext4.img" "$ext4dir/$partition"
	else
		sudo $BIN/make_ext4fs -J -T -1 \
		   -S "$ext4dir/config/$partition/${partition}_file_contexts" \
		   -C "$ext4dir/config/$partition/${partition}_fs_config" \
		   -l "$SIZE" \
		   -L "$partition" \
		   -a "/$partition" \
		   "$DIROUT/$partition.ext4.img" "$ext4dir/$partition"
	fi
}

repack_erofs_as_ext4_cmd() {
	local partition=$1
	local SIZE=$2
	$BIN/checkfsconfig $erofsdir/$partition $erofsdir/config/${partition}_fs_config
	if [[ $partition == system ]] || [[ $partition == system_a ]] || [[ $partition == system_b ]]; then
		sudo $BIN/make_ext4fs -J -T -1 \
		   -S "$erofsdir/config/${partition}_file_contexts" \
		   -C "$erofsdir/config/${partition}_fs_config" \
		   -l "$SIZE" \
		   -L "/" \
		   -a "/$partition" \
		   "$DIROUT/$partition.img" "$erofsdir/$partition"
	else
		sudo $BIN/make_ext4fs -J -T -1 \
		   -S "$erofsdir/config/${partition}_file_contexts" \
		   -C "$erofsdir/config/${partition}_fs_config" \
		   -l "$SIZE" \
		   -L "$partition" \
		   -a "/$partition" \
		   "$DIROUT/$partition.img" "$erofsdir/$partition"
	fi
}

repack_erofs_cmd() {
	local partition=$1
	local compression=$2
	local legacy=$3
	if [[ $legacy == "1" ]]; then
		local other=" -E legacy-compress"
	else
		local other=""
	fi
	
	$BIN/checkfsconfig $erofsdir/$partition $erofsdir/config/${partition}_fs_config
	$BIN/mkfs.erofs${other} \
	   -z${compression} \
	   -T $(date +%s) \
	   --workers=$(nproc --all) \
	   --mount-point="/$partition" \
	   --fs-config-file="$erofsdir/config/${partition}_fs_config" \
	   --file-contexts="$erofsdir/config/${partition}_file_contexts" \
	   "$DIROUT/$partition.erofs.img" "$erofsdir/$partition/"
}

repack_f2fs_cmd() {
	local partition=$1
	SIZE=$(( ((54 * 1024 * 1024) + $(du -sb "$f2fsdir/$partition" | awk '{print $1}') ) * 115 / 100 + 1))
	$BIN/checkfsconfig $f2fsdir/$partition $f2fsdir/config/${partition}_fs_config
	truncate -s $SIZE $f2fsdir/config/tmp/$partition.img
	$BIN/mkfs.f2fs $f2fsdir/config/tmp/$partition.img \
		-O extra_attr \
		-O inode_checksum \
		-O sb_checksum \
		-O compression -f

	if [[ $partition == system ]] || [[ $partition == system_a ]] || [[ $partition == system_b ]]; then
		$BIN/sload.f2fs -f "$f2fsdir/$partition" \
			-C "$f2fsdir/config/${partition}_fs_config" \
			-s "$f2fsdir/config/${partition}_file_contexts" \
			-T $(date +%s) \
			-t "/" \
			-c "$f2fsdir/config/tmp/$partition.img"
	else
		$BIN/sload.f2fs -f "$f2fsdir/$partition" \
			-C "$f2fsdir/config/${partition}_fs_config" \
			-s "$f2fsdir/config/${partition}_file_contexts" \
			-T $(date +%s) \
			-t "/$partition" \
			-c "$f2fsdir/config/tmp/$partition.img"
	fi
	cp $f2fsdir/config/tmp/$partition.img $DIROUT/$partition.f2fs.img
}

unpack_ext4_erofs_f2fs_img() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to unpack"
	echo " "
	file_selector $DIRIN ".img" "Unpack all .img shown above"
	for image in $FILE; do
	   if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == ext4 ]]; then
	       unpack_ext4
	   elif [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == erofs ]]; then
	       unpack_erofs
	   elif [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == f2fs ]]; then
	       unpack_f2fs
	   else
	       echo ""
	       echo -e "${R}$image.img fs type is not ext4/f2fs/erofs!"
	       echo -e "${NC}"
	   fi
	done
}

repack_ext4_img_foldersize() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $WORKDIR/EXT4 "Repack all images shown"
	for image in $FOLDER; do
	   if [[ -d $ext4dir/$image ]]; then
		echo ""
		echo "- Repacking $image..."
		echo ""
		local foldersize=$(sudo du -s -B1 $ext4dir/$image | awk '{print $1}')
		local SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
		    local SIZE=`sudo du -sk $ext4dir/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		if repack_ext4_cmd $image $SIZE; then
		   resize_img $DIROUT/$image.ext4.img smallest
		   echo ""
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.ext4.img ${NC}"
		else
		   echo ""
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	   fi
	done
}

repack_ext4_img_freespace() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $WORKDIR/EXT4
	local image=$FOLDER
	if [[ -d $ext4dir/$image ]]; then
		echo " "
		echo "Input $image free space in mb (megabytes) :"
		read
		local FREESPACE=$REPLY
		echo ""
		echo "- Repacking $image..."
		echo ""
		local foldersize=$(sudo du -s -B1 $ext4dir/$image | awk '{print $1}')
		local SIZE=$(($foldersize + $foldersize * 1/10))
		if (( $SIZE < 1474560 )); then
		    local SIZE=`sudo du -sk $ext4dir/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		if repack_ext4_cmd $image $SIZE; then
		   resize_img $DIROUT/$image.ext4.img freespace
		   echo ""
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.ext4.img ${NC}"
		else
		   echo ""
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_ext4_img_samesize() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $WORKDIR/EXT4 "Repack all images shown"
	for image in $FOLDER; do
	   if [[ -d $ext4dir/$image ]]; then
		echo ""
		echo "- Repacking $image..."
		echo ""
		local SIZE=$(cat $ext4dir/config/$image/${image}_size.txt)
		if (( $SIZE < 1474560 )); then
		    local SIZE=`sudo du -sk $ext4dir/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		if repack_ext4_cmd $image $SIZE; then
		   echo ""
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.ext4.img ${NC}"
		else
		   echo ""
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	   fi
	done
}

repack_ext4_img_inputsize() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $WORKDIR/EXT4
	local image=$FOLDER
	if [[ -d $ext4dir/$image ]]; then
		echo " "
		echo "Input partition size in bytes :"
		read
		local SIZE=$REPLY
		if (( $SIZE < 1474560 )); then
		    local SIZE=`sudo du -sk $ext4dir/$image | awk '{$1*=1024;$1=int($1*8);printf $1}'`
		fi
		echo ""
		echo "- Repacking $image..."
		echo ""
		if repack_ext4_cmd $image $SIZE; then
		   echo ""
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.ext4.img ${NC}"
		else
		   echo ""
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_erofs() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $erofsdir
	local image=$FOLDER
	if [[ -d $erofsdir/$image ]]; then
		while true; do
		    read -p "Compiling erofs image for old kernel? (Y/N)" yn
		    case $yn in
			[Yy]* ) 
			local legacy=1 
			break;;
			[Nn]* ) 
			local legacy=0 
			break;;
			* ) echo "Please answer yes or no.";;
		    esac
		done
		
		while true; do
		   echo " "
		   echo "Choose compressor : "
		   echo " "
		   echo "1. lz4"
		   echo "2. lz4hc"
		   echo "3. lzma"
		   echo "4. deflate"
			    
		   read -p "" choose
		   case $choose in
			    
			1 ) 
			local compressor=lz4
			break;;

			2 ) 
			local compressor=lz4hc
			break;;
			
			3 )
			local compressor=lzma
			break;;
			
			4 ) 
			local compressor=deflate
			break;;

			* ) choose_compressor;;
		   esac
		done
		
		case $compressor in
		   "lz4" )
		      local compression=lz4
		   ;;
		   
		   "lz4hc" )
		      echo ""
		      echo "Input erofs compression level (0-12, default is 9)"
		   ;;
		   
		   "lzma" )
		      echo ""
		      echo "Input erofs compression level (0-9,100-109. 0-9=normal, 100-109=extreme, default is 6)"
		   ;;
		   
		   "deflate" )
		      echo ""
		      echo "Input erofs compression level (0-9, default is 1)"
		   ;;
		esac
		
		if [[ $compressor != "lz4" ]]; then
		   echo "Leave it empty if you want the default compression"
		   read
		   local erofscomplvl=$REPLY
		   if [[ $erofscomplvl == "" ]]; then
		      local compression=${compressor}
		   else
		      local compression=${compressor},${erofscomplvl}
		   fi
		fi
		
		echo " "
		echo "- Repacking $image..."
		echo ""
		if repack_erofs_cmd $image $compression $legacy; then
		   echo ""
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.erofs.img ${NC}"
		else
		   echo ""
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}

repack_f2fs() {
	clear
	banner
	echo " "
	echo "choose which partition you wanted to repack"
	echo " "
	extracted_partition_selector $f2fsdir
	local image=$FOLDER
	if [[ -d $f2fsdir/$image ]]; then
		echo " "
		echo "- Repacking $image..."
		echo ""
		if repack_f2fs_cmd $image; then
		   echo ""
		   echo -e "${G}Repack done..."
		   echo -e "Output : $DIROUT/$image.f2fs.img ${NC}"
		else
		   echo ""s
		   echo -e "${R}Repack Failed!"
		   echo -e "${NC}"
		fi
	fi
}


erofs_ext4_main() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to convert to ext4"
	echo " "
	file_selector $DIRIN ".img" "Convert all image shown above to ext4"
	for image in $FILE; do
	   if [[ $(blkid -o value -s TYPE $DIRIN/$image.img) == erofs ]]; then
	      convert_erofs_ext4
	      rm -rf $erofsdir
	   else
	      echo ""
	      echo -e "${R}$image.img fs type is $(blkid -o value -s TYPE $DIRIN/$image.img), aborting..."
	      echo -e "${NC}"
	   fi
	done
	restart_tool
}

sparsechunk_converter() {
	clear
	banner
	echo ""
	echo "Input sparsechunk name:"
	echo 'example.. sparsechunk name is "super.img_sparsechunk.0-12", write "super.img_sparsechunk" here'
	read
	local SPARSECHUNK=$REPLY
	
	if [[ -f $DIRIN/$SPARSECHUNK.0 ]]; then
	   echo ""
	   echo "Converting sparsechunk image into raw image"
	   simg2img $DIRIN/$SPARSECHUNK.* $DIROUT/super.img
	   rm -rf $DIRIN/$SPARSECHUNK.*
	   if [[ -f $DIROUT/super.img ]]; then
	       echo -e "${G}Done! Output : $DIROUT/super.img ${NC}"
	   else
	       echo -e "${R}Conversion Failed!"
	       echo -e "${NC}"
	   fi
	else
	  echo -e "${R}No sparsechunk with the name of $SPARSECHUNK in input ${NC}"
	fi
}

merge_oplus() {
	clear
	if [[ -f $DIRIN/system_file_contexts ]] && [[ -f $DIRIN/system_fs_config ]]; then
		merge() {
			if [[ -f $DIRIN/${partition}_file_contexts ]] && [[ -f $DIRIN/${partition}_fs_config ]]; then
				echo ""
				echo "Merging $partition fs config & file contexts to system"
				echo ""
				gawk -i inplace 'NR>1' $DIRIN/${partition}_file_contexts

				patch_merge_fsconf_contexts $partition $DIRIN/${partition}_fs_config $DIRIN/${partition}_file_contexts

				cat $DIRIN/${partition}_file_contexts >> $DIRIN/system_file_contexts
				cat $DIRIN/${partition}_fs_config >> $DIRIN/system_fs_config
			else
				echo ""
				echo -e "${R}There's no $partition file contexts and/or fs config supplied ${NC}"
				echo ""
			fi
	   	}
		   
	   	for partition in $oplus_partitions
	   	do
			merge
	   	done

	   	rm -rf $DIRIN/my_*
	  	mv $DIRIN/system_file_contexts $DIROUT/
	   	mv $DIRIN/system_fs_config $DIROUT/
			
		echo -e "${G}merged all fs context and config.. Output : $DIROUT ${NC}"

	else
		echo -e "${R}Error: put your system_file_contexts & system_fs_config to $DIRIN"
		echo -e "${NC}"
		
	fi
}

merge_non_dynamic() {
	clear
	if [[ -f $DIRIN/system_file_contexts ]] && [[ -f $DIRIN/system_fs_config ]] && [[ -f $DIRIN/system_ext_file_contexts ]] && [[ -f $DIRIN/system_ext_fs_config ]] && [[ -f $DIRIN/product_file_contexts ]] && [[ -f $DIRIN/product_fs_config ]]; then
		gawk -i inplace 'NR>1' $DIRIN/system_ext_file_contexts
		gawk -i inplace 'NR>1' $DIRIN/product_file_contexts
			
		patch_merge_fsconf_contexts system_ext $DIRIN/system_ext_fs_config $DIRIN/system_ext_file_contexts
		patch_merge_fsconf_contexts product $DIRIN/product_fs_config $DIRIN/product_file_contexts

		cat $DIRIN/system_ext_file_contexts >> $DIRIN/system_file_contexts
		cat $DIRIN/system_ext_fs_config >> $DIRIN/system_fs_config

		cat $DIRIN/product_file_contexts >> $DIRIN/system_file_contexts
		cat $DIRIN/product_fs_config >> $DIRIN/system_fs_config

		rm -rf $DIRIN/product*
		rm -rf $DIRIN/system_ext*
		mv $DIRIN/system_file_contexts $DIROUT/
		mv $DIRIN/system_fs_config $DIROUT/
	else
		echo -e "${R}Error: you probably missed some important partitions fs conf and context..."
		echo -e "${NC}"
	fi
}

mount_imgs() {
	local OPTIONS=$1
	clear
	local images=$(ls -l $WORKDIR | grep -v '^d' | grep .img | awk '{print $9}' | sed 's/\.img$//')
	for partition in $images; do
		mkdir -p $WORKDIR/$partition
		sudo mount -t ext4 -o $OPTIONS $WORKDIR/${partition}.img $WORKDIR/$partition >> /dev/null 2>&1
		give_perm $partition
	done
}

mount_resize() {
	clear
	local images=$(ls -l $WORKDIR | grep -v '^d' | grep .img | awk '{print $9}' | sed 's/\.img$//')
	resize_img_to_edit(){
		local getsize=$(ls -nl $WORKDIR/${valset}.img | awk '{print $5}')
		local readmb=$(($getsize / 100000000))
		local readgiga=$(($getsize / 1000000000))
		local cval=$(($readmb - $readgiga))
		if [[ $cval -gt 5 ]]; then
			local vplus=2;
		else
			local vplus=1;
		fi
		local sizeimg=$(($readgiga + $vplus))G
		sudo fallocate -l $sizeimg $WORKDIR/${valset}.img
		sudo e2fsck -yf $WORKDIR/${valset}.img
		sudo resize2fs $WORKDIR/${valset}.img $sizeimg
		sudo e2fsck -yf $WORKDIR/${valset}.img
	}

	echo " "
	echo "Resizing partitions..."

	for valset in $images; do
		resize_img_to_edit
	done

	echo " "
	echo "Mounting partitions..."
	for partition in $images; do
		mkdir -p $WORKDIR/$partition
		sudo mount -t ext4 -o loop $WORKDIR/${partition}.img $WORKDIR/$partition >> /dev/null 2>&1
		give_perm $partition
	done
}

umount_resize_freespace() {
	clear
	local images=$(ls -l $WORKDIR | grep -v '^d' | grep .img | awk '{print $9}' | sed 's/\.img$//')
	resize_to_build(){
		sudo e2fsck -yf $WORKDIR/${valset}.img > /dev/null 2>&1
		sudo resize2fs -M $WORKDIR/${valset}.img > /dev/null 2>&1
		sudo e2fsck -yf $WORKDIR/${valset}.img > /dev/null 2>&1
				
		vsizenow=$(ls -nl $WORKDIR/${valset}.img | awk '{print $5}')
		sizeimg=$((($vsizenow + ${FREESPACE}000000)/1000))K
		sudo resize2fs $WORKDIR/${valset}.img $sizeimg > /dev/null 2>&1
		sudo e2fsck -yf $WORKDIR/${valset}.img > /dev/null 2>&1
	}

	echo " "
	echo "Input partition that you want to unmount :"
	file_selector $WORKDIR ".img"
	local PARTITION=$(echo $FILE | sed 's/\.img$//')
		
	echo " "
	echo "Input partiton free space in mb (megabytes) :"
	read
	local FREESPACE=$REPLY
			
	echo " "
	echo "Unmounting $PARTITION..."
	echo " "
	restore_perm $PARTITION > /dev/null 2>&1
	sudo umount $WORKDIR/$PARTITION >> /dev/null 2>&1
	rm -rf $WORKDIR/$PARTITION

	echo "Resizing $PARTITION..."
	echo " "
	local valset=$PARTITION
	resize_to_build
}

umount_resize() {
	clear
	local images=$(ls -l $WORKDIR | grep -v '^d' | grep .img | awk '{print $9}' | sed 's/\.img$//')
	resize_to_build(){
		sudo e2fsck -yf $WORKDIR/${valset}.img
		sudo resize2fs -M $WORKDIR/${valset}.img
		sudo e2fsck -yf $WORKDIR/${valset}.img
	}
	echo " "
	echo "Unmounting partitions..."
	echo " "
	for partition in $images; do
	   restore_perm $partition > /dev/null 2>&1
	   sudo umount $WORKDIR/$partition >> /dev/null 2>&1
	   rm -rf $WORKDIR/$partition
	done

	echo "Resizing partitions..."
	echo " "
	# Resize image to minimum
	for valset in $images; do
	  resize_to_build > /dev/null 2>&1
	done
}
	
umount_normal() {
	clear
	echo " "
	echo "Unmounting partitions..."
	echo " "
	local images=$(ls -l $WORKDIR | grep -v '^d' | grep .img | awk '{print $9}' | sed 's/\.img$//')
	for partition in $images; do
	   restore_perm $partition > /dev/null 2>&1
 	   sudo umount $WORKDIR/$partition >> /dev/null 2>&1
 	   rm -rf $WORKDIR/$partition
	done
}

payload() {
	clear
	if [ -f $DIRIN/payload.bin ]; then
		$BIN/payload $DIRIN/payload.bin -c $(nproc --all) -o $DIROUT

		echo " "
		echo "cleaning..."

		rm -rf $DIRIN/payload.bin

		echo " "
		echo -e "Done! Output : $DIROUT ${NC}"
	else
		echo -e "${R}there's no payload.bin in $DIRIN"
		echo -e "${NC}"
	fi
}

custom_scripts() {
	clear
	banner
	echo ""
	echo "Choose which script to run :"
	ls -1 $DIRSCRIPTS/custom_scripts | awk '{print NR ".", $0}'
	echo "x. Back to main menu"
	read
	local CHOOSE=$REPLY
	if [[ $CHOOSE == "x" ]]; then
	   start_tools
	elif [[ $CHOOSE == "" ]]; then
	   custom_scripts
	else
	   SCRIPT=$(ls -1 $DIRSCRIPTS/custom_scripts | awk '{print NR ".", $0}' | grep -E "\b${CHOOSE}.(\s|$)" | awk '{print $2}')
	   exec $DIRSCRIPTS/custom_scripts/$SCRIPT
	fi
}

raw_sparse() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to convert to sparse img"
	echo " "
	file_selector $DIRIN ".img"
	local imgname=$FILE

	if [ -f $DIRIN/$imgname.img ]; then
		echo " "
		echo "Converting raw image to sparse..."

		img2simg $DIRIN/$imgname.img $DIROUT/$imgname.sparse.img
		echo " "
		if [[ -f $DIROUT/$imgname.sparse.img  ]] && [[ $(ls -l $DIROUT/$imgname.sparse.img | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIRIN/$imgname.img
		   echo -e "${G}Done! Output : $DIROUT/$imgname.sparse.img ${NC}"
		else
		   echo -e "${R}Conversion Failed!"
		   echo -e "${NC}"
		fi
	fi
}

raw_datbr() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to compress"
	echo " "
	file_selector $DIRIN ".img"
	local imgname=$FILE

	if [ -f $DIRIN/$imgname.img ]; then
		echo " "
		echo "Input Brotli compression level (0-11) :"
		read
		local COMPLVL=$REPLY

		echo " " 
		echo "converting image : $imgname to sparse"
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img

		echo " " 
		echo "converting image : $imgname to new.dat"
		python3 $PYSCRIPTS/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIOUT/ -v 4 -p $imgname >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.sparse.img

		echo " " 
		echo "compressing image : $imgname using brotli..."

		brotli -q $COMPLVL $DIROUT/$imgname.new.dat
		echo " "
		echo "cleaning..."

		rm -rf $DIROUT/$imgname.new.dat
		echo " "
		if [[ -f $DIROUT/$imgname.new.dat.br ]]; then
		   echo -e "Done! Output : $DIROUT/$imgname.new.dat.br ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi
}

inc_dynamic_compress() {
	clear
	while true; do
	echo "Make sure you have already put the partitions you want to compress to input folder"
	echo "and remove/move partitions that you dont want to compress from input folder"
	echo "Type y/Y to continue, x/X to go back"
	read -p "" yn
	case $yn in
		[Yy]* ) 
		break;;
		[Xx]* ) 
		start_tools;;   
		* ) echo "please choose y or x";;
		esac
	done

	local dynamic_part_op_list=$DIROUT/dynamic_partitions_op_list
	local updater_script=$DIROUT/updater-script
	local inc_dynamic_imgs=$(ls -l $DIRIN/ | grep -v '^d' | grep .img | awk '{print $9}' | sed 's/\.img$//' | sed '/^$/d')

	echo ""
	echo "Reading configurations from $DIRSCRIPTS/incremental_dynamic.conf..."
	local SUPERSIZE=$(getvalue SUPER_SIZE $DIRSCRIPTS/incremental_dynamic.conf)
	local ACTIVESLOT=$(getvalue ACTIVE_SLOT $DIRSCRIPTS/incremental_dynamic.conf)
	local GROUPTABLE=$(getvalue GROUP_TABLE $DIRSCRIPTS/incremental_dynamic.conf)
	echo "Max Super partition size: ${SUPERSIZE}"
	echo "Group table: ${GROUPTABLE}"
	echo "Active Slot: ${ACTIVESLOT}"

	if [[ $ACTIVESLOT == "a" ]]; then
		local EMPTYSLOT=b
	elif [[ $ACTIVESLOT == "b" ]]; then
		local EMPTYSLOT=a
	elif [[ $ACTIVESLOT == "" ]]; then
		echo "A Only Device detected"
	else
		echo -e "${R}What??? slot ${ACTIVESLOT}???${NC}"
		restart_tool
	fi

	generate_op_list() {
		echo "Generating dynamic_partitions_op_list..."
		if [[ $ACTIVESLOT != "" ]]; then
			echo "# Remove all existing dynamic partitions and groups before applying full OTA" > $dynamic_part_op_list
			echo "remove_all_groups" >>  $dynamic_part_op_list
			echo "# Add group ${GROUPTABLE}_${ACTIVESLOT} with maximum size ${SUPERSIZE}" >> $dynamic_part_op_list
			echo "add_group ${GROUPTABLE}_${ACTIVESLOT} ${SUPERSIZE}" >> $dynamic_part_op_list
			echo "# Add group ${GROUPTABLE}_${EMPTYSLOT} with maximum size ${SUPERSIZE}" >> $dynamic_part_op_list
			echo "add_group q${GROUPTABLE}_${EMPTYSLOT} ${SUPERSIZE}" >> $dynamic_part_op_list
			
			for partition in $(echo $inc_dynamic_imgs); do
			   if [[ -f $DIRIN/$partition.img ]]; then
			      echo "# Add partition ${partition}_${ACTIVESLOT} to group ${GROUPTABLE}_${ACTIVESLOT}" >> $dynamic_part_op_list
			      echo "add ${partition}_${ACTIVESLOT} ${GROUPTABLE}_${ACTIVESLOT}" >> $dynamic_part_op_list
			      echo "# Add partition ${partition}_${EMPTYSLOT} to group ${GROUPTABLE}_${EMPTYSLOT}" >> $dynamic_part_op_list
			      echo "add ${partition}_${EMPTYSLOT} ${GROUPTABLE}_${EMPTYSLOT}" >> $dynamic_part_op_list
			   fi
			done
			for partition in $(echo $inc_dynamic_imgs); do
			   if [[ -f $DIRIN/$partition.img ]]; then
			      local partitionsize=$(ls -nl $DIRIN/$partition.img | awk '{print $5}')
			      echo "# Grow partition ${partition}_${ACTIVESLOT} from 0 to $partitionsize" >> $dynamic_part_op_list
			      echo "resize ${partition}_${ACTIVESLOT} $partitionsize" >> $dynamic_part_op_list
			   fi
			done
		else
			echo "# Remove all existing dynamic partitions and groups before applying full OTA" > $dynamic_part_op_list
			echo "remove_all_groups" >>  $dynamic_part_op_list
			echo "# Add group ${GROUPTABLE} with maximum size ${SUPERSIZE}" >>  $dynamic_part_op_list
			echo "add_group ${GROUPTABLE} ${SUPERSIZE}" >>  $dynamic_part_op_list
			
			for partition in $(echo $inc_dynamic_imgs); do
			   if [[ -f $DIRIN/$partition.img ]]; then
			      echo "# Add partition $partition to group ${GROUPTABLE}" >>  $dynamic_part_op_list
			      echo "add $partition ${GROUPTABLE}" >>  $dynamic_part_op_list
			   fi
			done
			for partition in $(echo $inc_dynamic_imgs); do
			   if [[ -f $DIRIN/$partition.img ]]; then
			      local partitionsize=$(ls -nl $DIRIN/$partition.img | awk '{print $5}')
			      echo "# Grow partition $partition from 0 to $partitionsize" >>  $dynamic_part_op_list
			      echo "resize ${partition} $partitionsize" >>  $dynamic_part_op_list
			   fi
			done
		fi
	}

	generate_updater_script() {
		echo "Generating updater-script..."
		echo "assert(update_dynamic_partitions(package_extract_file("dynamic_partitions_op_list")));" > $updater_script
		if [[ $ACTIVESLOT != "" ]]; then
			for partition in $(echo $inc_dynamic_imgs); do
				if [[ -f $DIRIN/$partition.img ]]; then
					echo "" >> $updater_script
					echo "ui_print(\"Flashing ${partition}_${ACTIVESLOT} partition...\");" >> $updater_script
					echo "block_image_update(map_partition(\"${partition}_${ACTIVESLOT}\"), package_extract_file(\"${partition}.transfer.list\"), \"${partition}.new.dat.br\", \"${partition}.patch.dat\") ||" >> $updater_script
					echo "  abort(\"E1001: Failed to flash ${partition}_${ACTIVESLOT} partition.\");" >> $updater_script
					echo "" >> $updater_script
				fi
			done
		else
			for partition in $(echo $inc_dynamic_imgs); do
				if [[ -f $DIRIN/$partition.img ]]; then
					echo "" >> $updater_script
					echo "ui_print(\"Flashing ${partition} files...\");" >> $updater_script
					echo "block_image_update(map_partition(\"${partition}\"), package_extract_file(\"${partition}.transfer.list\"), \"${partition}.new.dat.br\", \"${partition}.patch.dat\") ||" >> $updater_script
					echo "  abort(\"E1001: Failed to update ${partition} image.\");" >> $updater_script
					echo "" >> $updater_script
				fi
			done
		fi	
	}

	brotli_lvl() {
		echo " "
		echo "Input Brotli compression level (0-11) :"
		read
		COMPLVL=$REPLY
	}

	sparse() {
	    if [[ -f $DIRIN/$partition.img ]]; then
	    	echo ""
	    	echo "converting $partition into sparse"
	    	img2simg $DIRIN/$partition.img $DIRIN/$partition.sparse.img >> /dev/null 2>&1
	    	rm -rf $DIRIN/$partition.img
	    else
	    	echo " "
	    	echo -e "${R}there's no $partition.img supplied! skipping...${NC}"
	    fi
	}

	img2sdat() {
	    if [[ -f $DIRIN/$partition.sparse.img ]]; then
	    	echo " "
	    	echo "converting $partition into new.dat"
	    	python3 $PYSCRIPTS/img2sdat.py $DIRIN/$partition.sparse.img -o $DIROUT/ -v 4 -p $partition >> /dev/null 2>&1
	    	rm -rf $DIRIN/$partition.sparse.img
	    else
	    	echo " "
	    	echo -e "${R}there's no $partition.sparse.img supplied! skipping...${NC}"
	    fi
	}

	datbr() {
	    if [[ -f $DIROUT/$partition.new.dat ]]; then
	    	echo " " 
	    	echo "compressing $partition using brotli..."
	    	brotli -q $COMPLVL $DIROUT/$partition.new.dat
	    	rm -rf $DIROUT/$partition.new.dat
	    else
	    	echo " "
	    	echo -e "${R}there's no $partition.new.dat supplied! skipping...${NC}"
	    fi
	}

	compress() {
		echo "========================================="

		for partition in $(echo $inc_dynamic_imgs); do
		  sparse
		done

		echo " "
		echo "========================================="

		for partition in $(echo $inc_dynamic_imgs); do
		  img2sdat
		done

		echo " "
		echo "========================================="

		for partition in $(echo $inc_dynamic_imgs); do
		  datbr
		done

		echo " "
		echo "========================================="
		echo " "
		echo -e "${G}Done! Output : $DIROUT ${NC}"

	}
		
	local TOTALSIZE=$(ls -l $DIRIN/*.img 2>/dev/null | awk 'NF {sum += $5} END {print sum+0}')

	if (( $TOTALSIZE > $SUPERSIZE )); then
		echo ""
		echo -e "${R}Total size of all partitions exceeds max super size, aborting...${NC}"
		echo -e "${R}($TOTALSIZE/$SUPERSIZE)${NC}"
	else
		echo ""
		echo "Total size :"
		echo -e "${G}($TOTALSIZE/$SUPERSIZE)${NC}"
		brotli_lvl
		echo ""
		generate_op_list
		generate_updater_script
		echo ""
		compress
		rm -rf $DIRIN/*.sparse.img
	fi
}

inc_dynamic_decompress() {
	clear
	local inc_dynamic_compressed_imgs=$(ls -l $DIRIN/ | grep -v '^d' | grep .new.dat.br | awk '{print $9}' | sed 's/\.new.dat.br$//' | sed '/^$/d')

	datbr() {
	    if [[ -f $DIRIN/$partition.new.dat.br ]]; then
		echo " "
		echo "Decompressing $partition using brotli..."
		brotli -d $DIRIN/$partition.new.dat.br
		rm -rf $DIRIN/$partition.new.dat.br
	    else
	    	echo " "
	    	echo -e "${R}there's no $partition.new.dat.br supplied! skipping...${NC}"
	    fi
	}

	sdat2img() {
	    if [[ -f $DIRIN/$partition.new.dat ]] && [[ -f $DIRIN/$partition.transfer.list ]]; then
		echo " "
		echo "Converting $partition.new.dat to $partition.img (raw)"
		python3 $PYSCRIPTS/sdat2img.py $DIRIN/$partition.transfer.list $DIRIN/$partition.new.dat $DIROUT/$partition.img >> /dev/null 2>&1
		rm -rf $DIRIN/$partition.*
	    else
	    	echo " "
	    	echo -e "${R}there's no $partition.new.dat and/or $partition.transfer.list supplied! skipping...${NC}"
	    fi
	}

	echo "========================================="

	for partition in $(echo $inc_dynamic_compressed_imgs); do
	  datbr
	done

	echo " "
	echo "========================================="

	for partition in $(echo $inc_dynamic_compressed_imgs); do
	  sdat2img
	done

	echo " "
	echo "========================================="
	echo " "
	echo -e "${G}Done! Output : $DIROUT ${NC}"
}

sparse_raw() {
	clear
	banner
	echo " "
	echo "choose which image you wanted to convert to raw img"
	echo " "
	file_selector $DIRIN ".img"
	local imgname=$FILE
	
	if [ -f $DIRIN/$imgname.img ]; then
		echo " "
		echo "Converting sparse to raw image..."
		simg2img $DIRIN/$imgname.img $DIROUT/$imgname.img >> /dev/null 2>&1
		echo " "
		if [[ -f $DIROUT/$imgname.img ]] && [[ $(ls -l $DIROUT/$imgname.img | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIRIN/$imgname.img
		   echo -e "${G}Done! Output : $DIROUT/$imgname.img ${NC}"
		else
		   echo -e "${R}Decompression Failed!"
		   echo -e "${NC}"
		fi
	fi
}

super_u_raw() {
	clear
	banner
	echo " "
	echo "choose which super partition you wanted to extract"
	echo " "
	file_selector $DIRIN ".img"
	local imgname=$FILE

	if [ -f $DIRIN/$imgname.img ]; then
		if [[ -d $superdir ]]; then
			echo "Theres super extracted on $superdir, it will be deleted!"
			echo "Move it somewhere first if its important"
			echo "Press ENTER to confirm."
			read
			rm -rf $superdir
		fi
		echo " "
		echo "Unpacking $imgname.img..."
		mkdir -p $superdir/config
		lpdump --slot=0 $DIRIN/$imgname.img > $superdir/config/super_config.txt
		lpunpack $DIRIN/$imgname.img $WORKDIR/super
		rm -rf $DIRIN/$imgname.*

		echo " "
		echo -e "${G}Done! Output : $WORKDIR/super ${NC}"
	fi
}
	
super_u_zstd() {
	clear
	banner
	echo " "
	echo "choose which super partition you wanted to extract"
	echo " "
	file_selector $DIRIN ""
	local filename=$FILE
	
	if [[ $(file $DIRIN/$filename | grep "Zstandard") != "" ]]; then
		if [[ -d $superdir ]]; then
			echo "Theres super extracted on $superdir, it will be deleted!"
			echo "Move it somewhere first if its important"
			echo "Press ENTER to confirm."
			read
			rm -rf $superdir
		fi
		mv $DIRIN/$filename $DIRIN/$filename.zst
		
		echo " "
		echo "Decompressing $filename (zstd)"
		zstd -d $DIRIN/$filename.zst -o $DIRIN/super.img
		rm -rf $DIRIN/$filename.*

		echo " "
		echo "Unpacking super..."
		mkdir -p $superdir/config
		lpdump --slot=0 $DIRIN/super.img > $superdir/config/super_config.txt
		lpunpack $DIRIN/super.img $WORKDIR/super
		rm -rf $DIRIN/super.img

		echo " "
		echo -e "${G}Done! Output : $WORKDIR/super ${NC}"
	else
		echo " "
		echo -e "${R}File type is not Zstandard! aborting...${NC}"
	fi
}

super_u_datbr() {
	clear
	banner
	echo " "
	echo "choose which super partition you wanted to extract"
	echo " "
	file_selector $DIRIN ".new.dat.br"
	local imgname=$FILE

	if [ -f $DIRIN/$imgname.new.dat.br ]; then
		if [[ -d $superdir ]]; then
			echo "Theres super extracted on $superdir, it will be deleted!"
			echo "Move it somewhere first if its important"
			echo "Press ENTER to confirm."
			read
			rm -rf $superdir
		fi
		echo "Decompressing brotli..."
		brotli -d $DIRIN/$imgname.new.dat.br
		rm -rf $DIRIN/$imgname.new.dat.br

		echo " "
		echo "Converting $imgname.new.dat to $imgname.img (raw)..."
		python3 $PYSCRIPTS/sdat2img.py $DIRIN/$imgname.transfer.list $DIRIN/$imgname.new.dat $DIROUT/$imgname.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.*

		echo " "
		echo "Unpacking $imgname.img..."
		mkdir -p $superdir/config
		lpdump --slot=0 $DIROUT/$imgname.img > $superdir/config/super_config.txt
		lpunpack $DIROUT/$imgname.img $WORKDIR/super
		rm -rf $DIROUT/$imgname.*

		echo " "
		echo -e "${G}Done! Output : $WORKDIR/super ${NC}"
	fi
}

super_r() {
	if [[ $(ls $superdir ) == "" ]]; then
	    banner
	    echo ""
	    echo -e "${R}No super extracted!${NC}"
	    restart_tool
	fi
	local meta_size=$(cat $superdir/config/super_config.txt | awk '/Metadata max size:/ { print $4 }')
	local meta_slot=$(cat $superdir/config/super_config.txt | awk '/Metadata slot count:/ { print $4 }')
	local first_sector=$(cat $superdir/config/super_config.txt | awk '/First sector:/ { print ($3 * 512)}')
	local group_table=$(cat $superdir/config/super_config.txt | grep -A10 "Group table:" | grep "Name:" | awk '{ print $2 }' | sed -n "2p")
	local group_table2=$(cat $superdir/config/super_config.txt | grep -A10 "Group table:" | grep "Name:" | awk '{ print $2 }' | sed -n "3p")
	local virtualAB=$(cat $superdir/config/super_config.txt | awk '/Header flags:/ { print $3 }')
	local size_super=$(cat $superdir/config/super_config.txt | awk '/Size:/ { print $2 }')
	local max_size_super=$(cat $superdir/config/super_config.txt | grep -A11 "Group table:" | grep "Maximum size:" | awk '{ print $3 }' | sed -n "2p")
	local max_size_super2=$max_size_super

	local TOTALSIZE=$(ls -l $superdir/*.img 2>/dev/null | awk 'NF {sum += $5} END {print sum+0}')
	
	if [[ $virtualAB = "virtual_ab_device" ]]; then
	    local virtualABOption="--virtual-ab "
	else
	    local virtualABOption=""
	fi
	
	clear
	echo " "
	echo "Input Raw Super image name :"
	read
	local imgname=$REPLY
	echo " "
	while true; do
	    read -p "Your super raw img name is : $imgname is that correct? (Y/N)" yn
	    case $yn in
		[Yy]* ) break;;
		[Nn]* ) restart_tool;;
		* ) echo "Please answer yes or no.";;
	    esac
	done
	
	while true; do
	   echo ""
	   echo "Compress image to :"
	   echo "1. raw"
	   echo "2. sparse"
	   echo "3. new.dat"
	   echo "4. dat.br"
	   echo "5. zstd"
	   read -p "" choose
	   case $choose in
		[1]* ) 
		local COMPRESSION=raw
		break;;
		[2]* )
		local COMPRESSION=sparse
		break;;
		[3]* )
		local COMPRESSION=dat
		break;;
		[4]* )
		local COMPRESSION=br
		echo " "
		echo "Input Brotli compression level (0-11) :"
		read
		local COMPLVL=$REPLY
		break;;
		[5]* )
		local COMPRESSION=zstd
		echo " "
		echo "Input zstd suffix (leave it empty if you want .zst) :"
		read
		local ZSTDSUFFIX=.$REPLY
		if [[ $ZSTDSUFFIX == "." ]]; then
			local ZSTDSUFFIX=.zst
		elif [[ $ZSTDSUFFIX == ". " ]]; then
			local ZSTDSUFFIX=""
		fi
		echo " "
		echo "Input zstd compression lvl (1-19) :"
		read
		local ZSTDLVL=$REPLY
		break;;
			
		* ) echo "Please answer with one of the above selections.";;
	   esac
	done

	if [[ $meta_slot == 1 ]] || [[ $meta_slot == 2 ]]; then
		echo " "
		echo "A only detected..."
		echo "Compiling super with A only format"
		echo " "

		local part_list=$(cat $superdir/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }')
		local missing_imgs=()
		for partition in $part_list; do
			if [[ ! -f $superdir/$partition.img ]]; then
				local missing_imgs+=("$partition.img")
			fi
		done
		if [[ ${#missing_imgs[@]} -ne 0 ]]; then
			echo -e "${R}Missing images: ${missing_imgs[*]}${NC}"
			echo "Add the missing images to super directory or remove the partition from super config"
			restart_tool
		fi
		
		if (( $TOTALSIZE > $max_size_super )); then
			echo -e "${R}Total size of all partitions exceeds max super size, aborting...${NC}"
			echo -e "${R}($TOTALSIZE/$max_size_super)${NC}"
			echo ""
			restart_tool
		else
			echo "Super total size :"
			echo -e "${G}($TOTALSIZE/$max_size_super)${NC}"
			echo ""
			echo "Compiling super : $imgname.img (raw)..."
			
			echo "#!/bin/bash" > $DIRSCRIPTS/build_super
			echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot --device=super:$size_super:$first_sector --group=$group_table:$max_size_super '\'" >> $DIRSCRIPTS/build_super

			for partition in $part_list; do
				local partition_size=$(ls -nl $superdir/$partition.img | awk '{print $5}')
				echo "--partition=$partition:none:$partition_size:$group_table --image=$partition=$superdir/$partition.img '\'" >> $DIRSCRIPTS/build_super
			done

			echo "--output=$DIRIN/$imgname.img" >> $DIRSCRIPTS/build_super
			echo "exit" >> $DIRSCRIPTS/build_super
			
			sed -i "s/[']//g" $DIRSCRIPTS/build_super
			chmod 755 $DIRSCRIPTS/build_super
			$DIRSCRIPTS/build_super
			
			rm -rf $DIRSCRIPTS/build_super
		fi
	elif [[ $meta_slot == 3 ]]; then
		echo " "
		echo "Virtual A/B detected..."
		echo "Compiling super with Virtual A/B format"
		echo " "
		local slot_a_size=$(ls -l $superdir/*_a.img 2>/dev/null | awk 'NF {sum += $5} END {print sum+0}')
		local slot_b_size=$(ls -l $superdir/*_b.img 2>/dev/null | awk 'NF {sum += $5} END {print sum+0}')
		if (($slot_a_size > $slot_b_size)); then
			echo "Active Slot: A (Auto Detected)"
			echo " "
			local slot=_a
			local emptyslot=_b
		else
			echo "Active Slot: B (Auto Detected)"
			echo " "
			local slot=_b
			local emptyslot=_a
		fi

		local ab_part_list=$(cat $superdir/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }' | grep ${slot})
		local ab_part_list_empty=$(cat $superdir/config/super_config.txt | awk '/Partition table:/,/Super partition layout:/ {if ($1=="Name:") print $2 }' | grep ${emptyslot})
		local missing_imgs=()

		for partition in $ab_part_list; do
			if [[ ! -f $superdir/$partition.img ]]; then
				local missing_imgs+=("$partition.img")
			fi
		done
		if [[ ${#missing_imgs[@]} -ne 0 ]]; then
			echo -e "${R}Missing images: ${missing_imgs[*]}${NC}"
			echo "Add the missing images to super directory or remove the partition from super config"
			restart_tool
		fi
		
		if (( $TOTALSIZE > $max_size_super )); then
			echo -e "${R}Total size of all partitions exceeds max super size, aborting...${NC}"
			echo -e "${R}($TOTALSIZE/$max_size_super)${NC}"
			echo ""
			restart_tool
		else
			echo "Super total size :"
			echo -e "${G}($TOTALSIZE/$max_size_super)${NC}"
			echo ""
			echo "Compiling super : $imgname.img (raw)..."
			
			echo "#!/bin/bash" > $DIRSCRIPTS/build_super
			if [[ $group_table2 != "" ]]; then
				echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot ${virtualABOption}--device=super:$size_super:$first_sector --group=$group_table:$max_size_super --group=$group_table2:$max_size_super2 '\'" >> $DIRSCRIPTS/build_super
			else
				echo "lpmake --metadata-size=$meta_size --super-name=super --metadata-slots=$meta_slot ${virtualABOption}--device=super:$size_super:$first_sector --group=$group_table:$max_size_super '\'" >> $DIRSCRIPTS/build_super
			fi
			
			for partition in $ab_part_list; do
				local partition_size=$(ls -nl $superdir/$partition.img | awk '{print $5}')
				echo "--partition=$partition:none:$partition_size:$group_table --image=$partition=$superdir/$partition.img '\'" >> $DIRSCRIPTS/build_super
			done
			echo "--output=$DIRIN/$imgname.img" >> $DIRSCRIPTS/build_super
			
			if [[ $group_table2 != "" ]]; then
				echo "touch $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super
				for emptypartition in $ab_part_list_empty; do
				echo "lpadd $DIRIN/$imgname.img $emptypartition $group_table2 $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super
				done
				echo "rm -rf $DIRIN/tmp.img" >> $DIRSCRIPTS/build_super
			fi
			echo "exit" >> $DIRSCRIPTS/build_super
			
			sed -i "s/[']//g" $DIRSCRIPTS/build_super
			chmod 755 $DIRSCRIPTS/build_super
			$DIRSCRIPTS/build_super
			
			rm -rf $DIRSCRIPTS/build_super
		fi
	else
		echo -e "${R}Meta slot $meta_slot is not supported!"
		echo -e "${NC}"
	fi
	
	if [[ -f $DIRIN/$imgname.img ]]; then
		rm -rf $superdir
	fi
	
	case $COMPRESSION in
	   "raw" )
		echo " "
		mv $DIRIN/$imgname.img $DIROUT/$imgname.img
		if [[ -f $DIROUT/$imgname.img ]] && [[ $(ls -l $DIROUT/$imgname.img | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.img ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
		
	   "sparse" )
		echo " "
		echo "Converting raw $imgname.img to sparse..."
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		if [[ -f $DIRIN/$imgname.sparse.img ]] && [[ $(ls -l $DIRIN/$imgname.sparse.img | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIRIN/$imgname.img
		   mv $DIRIN/$imgname.sparse.img $DIROUT/$imgname.sparse.img
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.sparse.img ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
		
	   "dat" )
		echo " "
		echo "Converting raw $imgname.img to sparse..."
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img
		
		echo " "
		echo "Converting $imgname.img (sparse) to $imgname.new.dat..."
		python3 $PYSCRIPTS/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIROUT/ -v 4 -p $imgname >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.sparse.img
		if [[ -f $DIROUT/$imgname.new.dat ]] && [[ $(ls -l $DIROUT/$imgname.new.dat | awk '{print $5}') != "0" ]]; then
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.new.dat ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
	   
	   "br" )
		echo " "
		echo "Converting raw $imgname.img to sparse..."
		img2simg $DIRIN/$imgname.img $DIRIN/$imgname.sparse.img >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.img
		
		echo " "
		echo "Converting $imgname.img (sparse) to $imgname.new.dat..."
		python3 $PYSCRIPTS/img2sdat.py $DIRIN/$imgname.sparse.img -o $DIROUT/ -v 4 -p $imgname >> /dev/null 2>&1
		rm -rf $DIRIN/$imgname.sparse.img 
		
		echo " "
		echo "Compressing to $imgname.new.dat.br..."
		brotli -q $COMPLVL $DIROUT/$imgname.new.dat
		echo " "
		if [[ -f $DIROUT/$imgname.new.dat.br ]] && [[ $(ls -l $DIROUT/$imgname.new.dat.br | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIROUT/$imgname.new.dat
		   echo -e "${G}super build done! Output : $DIROUT/$imgname.new.dat.br ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
	   
	   "zstd" )
		echo " "
		echo "Compressing $imgname.img to ${imgname}$ZSTDSUFFIX (zstd)"
		zstd -${ZSTDLVL} -T$(nproc --all) $DIRIN/$imgname.img -o $DIROUT/${imgname}$ZSTDSUFFIX
		echo " "
		if [[ -f $DIROUT/${imgname}$ZSTDSUFFIX ]] && [[ $(ls -l $DIROUT/${imgname}$ZSTDSUFFIX | awk '{print $5}') != "0" ]]; then
		   rm -rf $DIRIN/$imgname.img
		   echo -e "${G}super build done! Output : $DIROUT/${imgname}$ZSTDSUFFIX ${NC}"
		else
		   echo -e "${R}Build Failed!"
		   echo -e "${NC}"
		fi
	   ;;
	esac
}

androidbooteditor() {
	while true; do
	    booteditor_banner
	    echo " "
	    echo "1. Repack Image"
	    echo "2. Unpack Image"
	    echo "c. Clean up"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 

	repack_bootimg
	restart_tool;;

		2 ) 
	   
	unpack_bootimg
	restart_tool;;

		x )  
	start_tools;;
		* ) androidbooteditor;;
	    esac
	done
}

install_proprietary() {
	install_dtc() {
		curl https://android.googlesource.com/platform/prebuilts/misc/+archive/refs/heads/android11-release/linux-x86/dtc.tar.gz -o $DIRTOOLS/dtc.tar.gz
		tar -xf $DIRTOOLS/dtc.tar.gz
		rm -rf $DIRTOOLS/PREBUILT
		chmod 777 $DIRTOOLS/dtc
		if [[ -f /usr/bin/dtc ]]; then
		   sudo rm -rf /usr/bin/dtc
		fi
		sudo mv $DIRTOOLS/dtc /usr/bin/dtc
		rm -rf $DIRTOOLS/dtc.tar.gz
	}
	while true; do
	    banner
		if command -v dnf >/dev/null 2>&1; then
			local PKGMAN=dnf
		elif command -v yum >/dev/null 2>&1; then
			local PKGMAN=yum
		elif command -v apt >/dev/null 2>&1; then
			local PKGMAN=apt
		elif command -v pacman >/dev/null 2>&1; then
			local PKGMAN=pacman
		else
			local PKGMAN="Error! Unknown Package Manager!"
		fi
		echo "Distro Base: $(grep -E "^ID_LIKE|^ID" /etc/os-release | cut -d'=' -f2 | tr -d '"')"
		echo "Package Manager: $PKGMAN"

		if [[ $PKGMAN == "Error! Unknown Package Manager!" ]]; then
		   echo "Unknown package manager! exiting tool!"
		   exit 0
		fi

	    	echo ""
	    	echo "Install proprietary packages? (Y/N)"
	    	read -p "" yn
		if [[ "$yn" =~ ^[Yy] ]]; then
			case $PKGMAN in
			"pacman" ) 
				sudo pacman -Sy --noconfirm android-tools erofs-utils gawk brotli cpio zstd
				install_dtc
				restart_tool;;
			
			"dnf" )
				sudo dnf install -y android-tools erofs-utils gawk brotli cpio zstd
				install_dtc
				restart_tool;;

			"yum" )
				sudo yum install -y android-tools erofs-utils gawk brotli cpio zstd
				install_dtc
				restart_tool;;

			"apt" )
				sudo apt install -y android-sdk-libsparse-utils erofs-utils gawk brotli cpio zstd
				install_dtc
				git clone https://github.com/Danda420/RomTools -b ubuntu-moment $DIRSCRIPTS/ubuntu-bins
				rm -rf $DIRSCRIPTS/ubuntu-bins/.git
				chmod 755 $DIRSCRIPTS/ubuntu-bins/*
				sudo mv $DIRSCRIPTS/ubuntu-bins/* /usr/bin/
				rm -rf $DIRSCRIPTS/ubuntu-bins
				restart_tool;;
			esac
		elif [[ "$yn" =~ ^[Nn] ]]; then
			start_tools
		fi
	done
}

merge_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Merge OPLUS my_* partition to system"
	    echo "2. Merge product and system_ext to system"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	merge_oplus
	restart_tool;;

		2 ) 
	merge_non_dynamic
	restart_tool;;

		x ) 
	start_tools;;

		* ) merge_main;;
	    esac
	done
}

mount_main() {
	while true; do
	    banner
	    echo " "
		echo "put your images on $WORKDIR"
		echo " "
	    echo "1. Mount raw image and resize"
	    echo "2. Mount without resizing"
	    echo "3. Mount read only"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	mount_resize
	restart_tool;;

		2 ) 
	mount_imgs "loop"
	restart_tool;;

		3 ) 
	mount_imgs "ro,nosuid,nodev,relatime,uhelper=udisks2,loop"
	restart_tool;;

		x ) 
	start_tools;;

		* ) mount_main;;
	    esac
	done
}

umount_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Umount raw image and resize to smallest size"
	    echo "2. Umount raw image and resize with free space "
	    echo "3. Umount without resizing"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	umount_resize
	restart_tool;;

		2 ) 
	umount_resize_freespace
	restart_tool;;

		3 ) 
	umount_normal
	restart_tool;;

		x ) 
	start_tools;;

		* ) umount_main;;
	    esac
	done
}

mount_umount_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Mount images"
	    echo "2. Umount Images"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	mount_main
	restart_tool;;

		2 ) 
	umount_main
	restart_tool;;
	
		x ) 
	start_tools;;

		* ) mount_umount_main;;
	    esac
	done
}

inc_dynamic_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack (raw to dat.br)"
	    echo "2. Unpack"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	inc_dynamic_compress
	restart_tool;;

		2 ) 
	inc_dynamic_decompress
	restart_tool;;

		x ) 
	start_tools;;

		* ) inc_dynamic_main;;
	    esac
	done
}

super_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack Super (raw, sparse, .dat, .br, zstd)"
	    echo "2. Unpack Super (dat.br)"
	    echo "3. Unpack Super (zstd)"
	    echo "4. Unpack Super (raw)"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	super_r
	restart_tool;;

		2 ) 
	super_u_datbr
	restart_tool;;

		3 ) 
	super_u_zstd
	restart_tool;;
	
		4 ) 
	super_u_raw
	restart_tool;;

		x ) 
	start_tools;;

		* ) super_main;;
	    esac
	done
}

repack_ext4_erofs_f2fs() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack EXT4 image with old image size"
	    echo "2. Repack EXT4 image with folder size"
	    echo "3. Repack EXT4 image with free space"
	    echo "4. Repack EXT4 image and manually input size"
	    echo "5. Repack EROFS image"
		echo "6. Repack F2FS image"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	repack_ext4_img_samesize
	restart_tool;;

		2 ) 
	repack_ext4_img_foldersize
	restart_tool;;
	
		3 )
	repack_ext4_img_freespace
	restart_tool;;
	
		4 ) 
	repack_ext4_img_inputsize
	restart_tool;;
	
		5 )
	repack_erofs
	restart_tool;;

		6 )
	repack_f2fs
	restart_tool;;
	
		x ) 
	start_tools;;

		* ) repack_ext4_erofs_f2fs;;
	    esac
	done
}

unpack_repack_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Repack EXT4/F2FS/EROFS image"
	    echo "2. Unpack EXT4/F2FS/EROFS image"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	repack_ext4_erofs_f2fs
	restart_tool;;

		2 ) 
	unpack_ext4_erofs_f2fs_img
	restart_tool;;
	
		x ) 
	start_tools;;

		* ) unpack_repack_main;;
	    esac
	done
}

cd_cv_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Convert dat.br to raw img"
	    echo "2. Convert raw .img to dat.br"
	    echo "3. Convert raw to sparse"
	    echo "4. Convert sparse to raw"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	datbr_raw
	restart_tool;;

		2 ) 
	raw_datbr
	restart_tool;;

		3 ) 
	raw_sparse
	restart_tool;;
	
		4 )
	sparse_raw
	restart_tool;;

		x ) 
	start_tools;;

		* ) cd_cv_main;;
	    esac
	done
}

zstd_main() {
	while true; do
	    banner
	    echo " "
	    echo "1. Compress zstd"
	    echo "2. Decompress zstd"
	    echo "x. Back to main menu"
	    
	    read -p "" choose
	    case $choose in
	    
		1 ) 
	compress_zstd
	restart_tool;;

		2 ) 
	decompress_zstd
	restart_tool;;

		x ) 
	start_tools;;

		* ) zstd_main;;
	    esac
	done
}

start_tools() {
	setup
	while true; do
	    banner
	    echo " "
	    echo "0. Android Boot Image Editor"
	    echo "1. Super partition tools"
	    echo "2. Incremental dynamic partition tools"
	    echo "3. Convert or compress images"
	    echo "4. Unpack or repack images"
	    echo "5. Convert erofs to ext4"
	    echo "6. Rebuild EXT4 Images (removes avb)"
	    echo "7. Mount or Umount raw imgs"
	    echo "8. Decompress Sparsechunk"
	    echo "9. Unpack payload.bin"
	    echo "10. Custom Scripts"
	    echo "11. Merge fs context and config to system"
	    echo "12. Zstd Tools"
	    echo "c. Clean up folders"
	    echo "i. Install proprietary packages"
	    echo "x. Exit tool"
	    
	    read -p "" choose
	    case $choose in
	    
		0 ) 
	androidbooteditor
	restart_tool;;

		1 ) 
	super_main
	restart_tool;;

		2 ) 
	inc_dynamic_main
	restart_tool;;

		3 ) 
	cd_cv_main
	restart_tool;;

		4 ) 
	unpack_repack_main
	restart_tool;;

		5 ) 
	erofs_ext4_main
	restart_tool;;

		6 ) 
	rebuild_ext4_single
	restart_tool;;

		7 ) 
	mount_umount_main
	restart_tool;;
	
		8 )
	sparsechunk_converter
	restart_tool;;

		9 ) 
	payload
	restart_tool;;

		10 ) 
	custom_scripts
	restart_tool;;

		11 ) 
	merge_main
	restart_tool;;
	
		12 ) 
	zstd_main
	restart_tool;;
	
		i ) 
	install_proprietary
	restart_tool;;

		c ) 
	clean
	restart_tool;;

		x )  
	clear	
	exit;;
		* ) start_tools;;
	    esac
	done
}
